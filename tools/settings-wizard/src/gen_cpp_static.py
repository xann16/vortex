from cpp_utils import get_class_name, get_namespace, add_include, add_blank, add_line, add_block_comment, begin_test_case, end_test_case, add_require, begin_namespace, end_namespace, begin_class, end_class, add_access_qualifier, add_ctor_declaration, add_ctor_definition, add_method_definition, add_method_declaration, add_function_declaration, add_function_definition, add_data_field
import gen_cpp_enums
from gen_cpp_properties import add_static_property_data_members, add_static_property_getters, has_any_heap_stored_properties, add_static_property_unit_tests, get_static_stringify_body, get_extra_data_size_body, get_hacky_static_ctor_params, get_extra_data_prep_code, get_hacky_static_ctor_call
from gen_utils import create_file
import os
from typing import Any

def get_header_path(data: dict[str, Any], suffix: str = '', root_path: str | None = None, ctx='cwd') -> str:
    package_name : str = data['__metadata__']['package'].lstrip('*')
    module_name : str = data['__metadata__']['module']
    namespace_path : list[str] = data['__metadata__']['namespace'] + ['stat']
    path = os.path.join(package_name, *namespace_path, module_name + suffix + '.hpp')
    if ctx == 'include':
        return os.path.normpath(path)
    path = os.path.join('include', path)
    if ctx == 'cmake':
        return os.path.normpath(path)
    path = os.path.join(root_path if root_path else '.', package_name, path)
    if ctx == 'cwd':
        return os.path.normpath(path)

    raise RuntimeError(f"Unsupported context: '{ctx}'.")


def get_source_path(data: dict[str, Any], suffix: str = '', root_path: str | None = None, ctx='cwd') -> str:
    package_name : str = data['__metadata__']['package'].lstrip('*')
    module_name : str = data['__metadata__']['module']
    namespace_path : list[str] = data['__metadata__']['namespace'] + ['stat']
    path = os.path.join('src', *namespace_path, module_name + suffix + '.cpp')
    if ctx == 'cmake':
        return os.path.normpath(path)
    path = os.path.join(root_path, package_name, path)
    if ctx == 'cwd':
        return os.path.normpath(path)

    raise RuntimeError(f"Unsupported context: '{ctx}'.")


def get_unit_test_path(data: dict[str, Any], suffix: str = '', root_path: str | None = None, ctx='cwd') -> str:
    package_name : str = data['__metadata__']['package'].lstrip('*')
    module_name : str = data['__metadata__']['module']
    namespace_path : list[str] = data['__metadata__']['namespace'] + ['stat']
    path = os.path.join('tests', *namespace_path, module_name + suffix + '.test.cpp')
    if ctx == 'cmake':
        return os.path.normpath(path)
    path = os.path.join(root_path, package_name, path)
    if ctx == 'cwd':
        return os.path.normpath(path)

    raise RuntimeError(f"Unsupported context: '{ctx}'.")


def populate_cmake_data(data: dict[str, Any], ctx : dict[str, Any]) -> None:
    package_name : str = data['__metadata__']['package'].lstrip('*')
    if package_name not in ctx['cmake']:
        ctx['cmake'][package_name] = {}
    pkg_data = ctx['cmake'][package_name]

    if 'headers' not in pkg_data:
        pkg_data['headers'] = []
    pkg_data['headers'].append(get_header_path(data, ctx='cmake'))
    pkg_data['headers'].append(get_header_path(data, ctx='cmake', suffix='_conversion'))

    if 'sources' not in pkg_data:
        pkg_data['sources'] = []
    pkg_data['sources'].append(get_source_path(data, ctx='cmake'))
    pkg_data['sources'].append(get_source_path(data, ctx='cmake', suffix='_conversion'))

    if 'tests' not in pkg_data:
        pkg_data['tests'] = []
    pkg_data['tests'].append(get_unit_test_path(data, ctx='cmake'))
    pkg_data['tests'].append(get_unit_test_path(data, ctx='cmake', suffix='_conversion'))


def _add_settings_includes(ls: list[str], i: int, includes: list[dict[str, Any]], ctx: dict[str, Any], suffix : str = '') -> int:
    for include_from in (include['from'] for include in includes):
        i = add_include(ls, i, get_header_path(ctx['defs'][include_from], ctx='include', suffix=suffix))
    return i


def _add_enum_includes(ls: list[str], i: int, data: dict[str, Any], ctx: str = 'base'):
    for prop_data in data.values():
        if 'type' in prop_data and prop_data['type'] == 'enum':
            enum_data: dict[str, Any] = prop_data['enum']
            include_path : str = gen_cpp_enums.get_header_include_path_ext(data, enum_data, ctx)
            i = add_include(ls, i, include_path)
    return i


def generate_static_header_file(root_path: str, data: dict[str, Any], ctx: dict[str, Any]) -> None:
    path : str = get_header_path(data, root_path=root_path)
    class_name : str = get_class_name(data)
    namespace : list[str] = get_namespace(data) + ['stat']

    ls : list[str] = []
    i = 0

    i = add_block_comment(ls, i, '', 'Header file auto-generated by VORTEX SETTINGS WIZARD', '', 'TODO: Just testing', '')
    add_blank(ls)

    i = add_line(ls, i, '#pragma once')
    add_blank(ls)

    i = add_include(ls, i, 'ostream', is_quoted=False)
    i = add_include(ls, i, 'string_view', is_quoted=False)
    i = add_include(ls, i, 'span', is_quoted=False)
    add_blank(ls)

    i = add_include(ls, i, 'core/common/types.hpp')
    i = _add_enum_includes(ls, i, data)
    if '__includes__' in data:
        i = _add_settings_includes(ls, i, data['__includes__'], ctx)
    add_blank(ls)

    i = begin_namespace(ls, i, *namespace)
    add_blank(ls)
    i = begin_class(ls, i, class_name)

    i = add_access_qualifier(ls, i, 'public')
    i = add_line(ls, i, f'{class_name}() noexcept = default;')
    i = add_ctor_declaration(ls, i, class_name, get_hacky_static_ctor_params(data, ctx), is_noexcept=True)

    i = add_access_qualifier(ls, i, 'public')
    i = add_static_property_getters(ls, i, data, ctx)
    add_blank(ls)

    i = add_method_declaration(ls, i, 'has_extra_data', 'bool', [], body=[(0, f'return {('true' if has_any_heap_stored_properties(data, ctx) else 'false')};')], is_const=True, is_nodiscard=True, is_noexcept=True, is_definition=True, pre_qualifiers='consteval')
    i = add_method_declaration(ls, i, 'extra_data_size', 'std::size_t', [], body=get_extra_data_size_body(data, ctx, is_static=True), is_const=True, is_nodiscard=True, is_noexcept=True, is_definition=True, pre_qualifiers='constexpr')
    add_blank(ls)

    i = add_method_declaration(ls, i, 'to_string', 'std::string', [], is_const=True, is_nodiscard=True)
    i = add_method_declaration(ls, i, 'stringify', 'std::ostream&', [('std::ostream&', 'os'), ('int', 'indent_size'), ('int', 'indent_level')], is_const=True)
    add_blank(ls)
    i = add_method_declaration(ls, i, 'operator<<', 'std::ostream&', [('std::ostream&', 'os'), (f'{class_name} const&', 's')], pre_qualifiers='friend')
    add_blank(ls)

    i = add_access_qualifier(ls, i, 'private')
    i = add_static_property_data_members(ls, i, data, ctx)

    i = end_class(ls, i, class_name)
    add_blank(ls)
    i = end_namespace(ls, i, *namespace)

    create_file(path, ls)


def generate_static_source_file(root_path: str, data: dict[str, Any], ctx: dict[str, Any]) -> None:
    path : str = get_source_path(data, root_path=root_path)
    class_name : str = get_class_name(data)
    namespace : str = get_namespace(data) + ['stat']

    ls : list[str] = []
    i = 0

    i = add_block_comment(ls, i,'', 'Source file auto-generated by VORTEX SETTINGS WIZARD', '', 'TODO: Just testing', '')
    add_blank(ls)

    i = add_include(ls, i, get_header_path(data, ctx='include'))
    add_blank(ls)

    i = add_include(ls, i, 'iomanip', is_quoted=False)
    i = add_include(ls, i, 'sstream', is_quoted=False)
    add_blank(ls)

    i = begin_namespace(ls, i, *namespace)
    add_blank(ls)

    i = add_ctor_definition(ls, i, class_name, get_hacky_static_ctor_params(data, ctx), body=[], is_noexcept=True)

    to_string_body : list[(int, str)] = [
        (0, 'auto oss = std::ostringstream{};'),
        (0, 'oss << *this;'),
        (0, 'return oss.str();')
    ]
    i = add_method_definition(ls, i, 'to_string', 'std::string', class_name, [], is_const=True, is_nodiscard=True, body=to_string_body)
    add_blank(ls)

    i = add_method_definition(ls, i, 'stringify', 'std::ostream&', class_name, [('std::ostream&', 'os'), ('int', 'indent_size'), ('int', 'indent_level')], body=get_static_stringify_body(data), is_const=True)
    add_blank(ls)

    op_ln : str = 'return s.stringify( os, 2, 0 );'
    i = add_function_definition(ls, i, 'operator<<', 'std::ostream&', [('std::ostream&', 'os'), (f'{class_name} const&', 's')], body=[(0, op_ln)])
    add_blank(ls)

    i = end_namespace(ls, i, *namespace)

    create_file(path, ls)


def generate_static_unit_test_file(root_path: str, data: dict[str, Any], ctx: dict[str, Any]) -> None:
    path : str = get_unit_test_path(data, root_path=root_path)
    class_name : str = get_class_name(data)
    namespace : str = get_namespace(data) + ['stat']

    ls : list[str] = []
    i = 0

    i = add_block_comment(ls, i,'', 'Unit test source file auto-generated by VORTEX SETTINGS WIZARD', '', 'TODO: Just testing', '')
    add_blank(ls)
    i = add_include(ls, i, 'catch2/catch_test_macros.hpp', is_quoted=False)
    i = add_include(ls, i, 'catch2/matchers/catch_matchers_floating_point.hpp', is_quoted=False)
    add_blank(ls)
    i = add_include(ls, i, get_header_path(data, ctx='include'))

    add_blank(ls)

    i = begin_test_case(ls, i, f'{class_name} - conversion to string - static', 'settings', '.', '!mayfail')
    i = add_block_comment(ls, i, 'TODO - add conversion to string tests for generated static setting classes')
    i = add_require(ls, i, 'false')
    i = end_test_case(ls, i)

    add_blank(ls)

    i = begin_test_case(ls, i, f'{class_name} - conversion to string - display all - static', 'settings', '.', '!mayfail')
    i = add_block_comment(ls, i, 'TODO - add conversion to string tests for generated static setting classes')
    i = add_require(ls, i, 'false')
    i = end_test_case(ls, i)

    add_blank(ls)

    i = begin_test_case(ls, i, f'{class_name} - conversion to string - extra indent size - static', 'settings', '.', '!mayfail')
    i = add_block_comment(ls, i, 'TODO - add conversion to string tests for generated static setting classes')
    i = add_require(ls, i, 'false')
    i = end_test_case(ls, i)

    add_blank(ls)

    i = begin_test_case(ls, i, f'{class_name} - conversion to string - extra indent level - static', 'settings', '.', '!mayfail')
    i = add_block_comment(ls, i, 'TODO - add conversion to string tests for generated static setting classes')
    i = add_require(ls, i, 'false')
    i = end_test_case(ls, i)

    add_blank(ls)

    i = begin_test_case(ls, i, f'{class_name} - conversion to string for empty - static', 'settings', '.', '!mayfail')
    i = add_block_comment(ls, i, 'TODO - add conversion to string tests for generated static setting classes')
    i = add_require(ls, i, 'false')
    i = end_test_case(ls, i)

    add_blank(ls)

    create_file(path, ls)

### CONVERSION

def generate_conversion_header_file(root_path: str, data: dict[str, Any], ctx: dict[str, Any]) -> None:
    path : str = get_header_path(data, root_path=root_path, suffix='_conversion')
    class_name : str = get_class_name(data)
    namespace : list[str] = get_namespace(data)

    ls : list[str] = []
    i = 0

    i = add_block_comment(ls, i, '', 'Header file auto-generated by VORTEX SETTINGS WIZARD', '', 'TODO: Just testing', '')
    add_blank(ls)

    i = add_line(ls, i, '#pragma once')
    add_blank(ls)

    i = add_include(ls, i, 'string_view', is_quoted=False)
    i = add_include(ls, i, 'span', is_quoted=False)
    add_blank(ls)

    i = add_include(ls, i, 'core/common/types.hpp')
    i = add_include(ls, i, 'core/settings/static_settings_data_storage.hpp')
    i = add_include(ls, i, get_header_path(data, ctx='include').replace('/stat/', '/'))
    i = add_include(ls, i, get_header_path(data, ctx='include'))
    i = _add_enum_includes(ls, i, data)
    if '__includes__' in data:
        i = _add_settings_includes(ls, i, data['__includes__'], ctx)
    add_blank(ls)

    i = begin_namespace(ls, i, *namespace)
    add_blank(ls)
    i = add_function_declaration(ls, i, 'to_static', 'stat::' + class_name, [(class_name + ' const&', 's'), ('[[maybe_unused]] ' + 'core::settings::StaticSettingsDataStorage&', 'data_storage')], is_nodiscard=True)
    i = add_function_declaration(ls, i, 'to_static_unchecked', 'stat::' + class_name, [(class_name + ' const&', 's'), ('[[maybe_unused]] ' + 'core::settings::StaticSettingsDataStorage&', 'data_storage')], is_nodiscard=True)
    i = add_function_declaration(ls, i, 'to_static_unchecked', 'stat::' + class_name, [(class_name + ' const&', 's'), ('[[maybe_unused]] ' + 'core::settings::StaticSettingsDataStorage&', 'data_storage'), ('[[maybe_unused]] ' + 'void **', 'data_offset_pp')], is_nodiscard=True)
    add_blank(ls)
    i = end_namespace(ls, i, *namespace)

    create_file(path, ls)


def generate_conversion_source_file(root_path: str, data: dict[str, Any], ctx: dict[str, Any]) -> None:
    path : str = get_source_path(data, root_path=root_path, suffix='_conversion')
    class_name : str = get_class_name(data)
    namespace : str = get_namespace(data)
    has_heap_data : bool = has_any_heap_stored_properties(data, ctx)

    ls : list[str] = []
    i = 0

    i = add_block_comment(ls, i,'', 'Source file auto-generated by VORTEX SETTINGS WIZARD', '', 'TODO: Just testing', '')
    add_blank(ls)

    i = add_include(ls, i, get_header_path(data, ctx='include', suffix='_conversion'))
    add_blank(ls)

    i = add_include(ls, i, 'cstring', is_quoted=False)
    add_blank(ls)

    if '__includes__' in data:
        i = _add_settings_includes(ls, i, data['__includes__'], ctx, suffix='_conversion')
    add_blank(ls)

    conv_body : list[(int, str)] = []
    conv_body.append((0, 's.validate();'))
    conv_body.append((0, f'return to_static_unchecked( s, data_storage );' ))

    uconv_body : list[(int, str)] = []
    if has_heap_data:
        uconv_body.append((0, 'auto heap_data_p = data_storage.allocate( s.extra_data_size() );'))
    uconv_body.append((0, f'return to_static_unchecked( s, data_storage, {"&heap_data_p" if has_heap_data else "nullptr"} );' ))

    rconv_body : list[(int, str)] = []

    if has_heap_data:
        rconv_body.extend(get_extra_data_prep_code(data, ctx))
    rconv_body.append((0, 'return ' + get_hacky_static_ctor_call(f'stat::{class_name}', data, ctx) + ';'))

    i = begin_namespace(ls, i, *namespace)
    add_blank(ls)
    i = add_function_definition(ls, i, 'to_static', 'stat::' + class_name, [(class_name + ' const&', 's'), ('[[maybe_unused]] ' + 'core::settings::StaticSettingsDataStorage&', 'data_storage')], body=conv_body, is_nodiscard=True)
    add_blank(ls)
    i = add_function_definition(ls, i, 'to_static_unchecked', 'stat::' + class_name, [(class_name + ' const&', 's'), ('[[maybe_unused]] ' + 'core::settings::StaticSettingsDataStorage&', 'data_storage')], body=uconv_body, is_nodiscard=True)
    add_blank(ls)
    i = add_function_definition(ls, i, 'to_static_unchecked', 'stat::' + class_name, [(class_name + ' const&', 's'), ('[[maybe_unused]] ' + 'core::settings::StaticSettingsDataStorage&', 'data_storage'), ('[[maybe_unused]] ' + 'void **', 'data_offset_pp')], body=rconv_body, is_nodiscard=True)
    add_blank(ls)
    i = end_namespace(ls, i, *namespace)

    create_file(path, ls)


def generate_conversion_unit_test_file(root_path: str, data: dict[str, Any], ctx: dict[str, Any]) -> None:
    path : str = get_unit_test_path(data, root_path=root_path, suffix='_conversion')
    class_name : str = get_class_name(data)
    namespace : str = get_namespace(data)

    ls : list[str] = []
    i = 0

    i = add_block_comment(ls, i,'', 'Unit test source file auto-generated by VORTEX SETTINGS WIZARD', '', 'TODO: Just testing', '')
    add_blank(ls)
    i = add_include(ls, i, 'catch2/catch_test_macros.hpp', is_quoted=False)
    i = add_include(ls, i, 'catch2/matchers/catch_matchers_floating_point.hpp', is_quoted=False)
    add_blank(ls)
    i = add_include(ls, i, 'nlohmann/json.hpp', is_quoted=False)
    i = add_include(ls, i, get_header_path(data, ctx='include', suffix='_conversion'))

    add_blank(ls)

    i = add_static_property_unit_tests(ls, i, data, ctx)
    add_blank(ls)

    create_file(path, ls)

#############################################################

def generate_cpp_static(root_path: str, data: dict[str, Any], ctx: dict[str, Any]) -> None:

    generate_static_header_file(root_path, data, ctx)
    generate_static_source_file(root_path, data, ctx)
    generate_static_unit_test_file(root_path, data, ctx)

    generate_conversion_header_file(root_path, data, ctx)
    generate_conversion_source_file(root_path, data, ctx)
    generate_conversion_unit_test_file(root_path, data, ctx)

    populate_cmake_data(data, ctx)
