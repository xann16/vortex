from cpp_utils import add_include, add_blank, add_line, open_brace, close_brace, add_block_comment, begin_test_case, end_test_case, add_require, begin_namespace, end_namespace, add_enum_class, add_function_declaration, add_function_definition
from gen_utils import create_file, to_pascal_case
import os
from typing import Any

JSON_INTEGRATION_SUFFIX = '_json_integration'

def _get_enum_class_name(enum_data: dict[str, Any]) -> str:
    return to_pascal_case(enum_data['name'])

def _get_package_name(data: dict[str, Any]) -> str:
    return data['__metadata__']['package'].lstrip('*')

def _get_namespace(data: dict[str, Any]) -> list[str]:
    return data['__metadata__']['namespace']

def get_header_path(enum_class_name: str, package_name: str, namespace_path: list[str], root_path: str | None = None, suffix : str = '', ctx='cwd') -> str:
    path : str = os.path.join(package_name, *namespace_path, 'enums', enum_class_name + suffix + '.hpp')
    if ctx == 'include':
        return os.path.normpath(path)
    path = os.path.join('include', path)
    if ctx == 'cmake':
        return os.path.normpath(path)
    path = os.path.join(root_path if root_path else '.', package_name, path)
    if ctx == 'cwd':
        return os.path.normpath(path)

    raise RuntimeError(f"Unsupported context: '{ctx}'.")

def get_header_include_path_ext(data: dict[str, Any], enum_data: dict[str, Any], ctx: str = 'base') -> str:
    package_name : str = _get_package_name(data)
    namespace : list[str] = _get_namespace(data)
    return get_header_path(enum_data['name'], package_name, namespace, ctx='include', suffix=(JSON_INTEGRATION_SUFFIX if ctx == 'json' else ''))

def get_source_path(enum_class_name: str, package_name: str, namespace_path: list[str], root_path: str | None = None, ctx='cwd') -> str:
    path : str = os.path.join('src', *namespace_path, 'enums', enum_class_name + '.cpp')
    if ctx == 'cmake':
        return os.path.normpath(path)
    path = os.path.join(root_path, package_name, path)
    if ctx == 'cwd':
        return os.path.normpath(path)

    raise RuntimeError(f"Unsupported context: '{ctx}'.")


def get_unit_test_path(enum_class_name: str, package_name: str, namespace_path: list[str], root_path: str | None = None, ctx='cwd') -> str:
    path : str = os.path.join('tests', *namespace_path, 'enums', enum_class_name + '.test.cpp')
    if ctx == 'cmake':
        return os.path.normpath(path)
    path = os.path.join(root_path, package_name, path)
    if ctx == 'cwd':
        return os.path.normpath(path)

    raise RuntimeError(f"Unsupported context: '{ctx}'.")


def generate_enum_header_file(root_path: str, data: dict[str, Any], enum_data: dict[str, Any], ctx: dict[str, Any]) -> None:
    enum_class_name : str = _get_enum_class_name(enum_data)
    package_name : str = _get_package_name(data)
    namespace : list[str] = _get_namespace(data)
    path : str = get_header_path(enum_data['name'], package_name, namespace, root_path=root_path)

    ls : list[str] = []
    i : int = 0

    i = add_block_comment(ls, i, '', 'Header file auto-generated by VORTEX SETTINGS WIZARD', '', 'TODO: Just testing', '')
    add_blank(ls)

    i = add_line(ls, i, '#pragma once')
    i = add_line(ls, i, '#pragma clang diagnostic push')
    i = add_line(ls, i, '#pragma clang diagnostic ignored "-Wcovered-switch-default"')
    add_blank(ls)

    i = add_include(ls, i, 'cstring', is_quoted=False)
    i = add_include(ls, i, 'string', is_quoted=False)
    add_blank(ls)

    i = begin_namespace(ls, i, *(['vortex', package_name] + namespace))
    add_blank(ls)
    i = add_enum_class(ls, i, enum_data['name'], enum_data['values'])
    add_blank(ls)

    body_to_str : list[(int, str)] = []

    body_to_str.append((0, 'switch( value )'))
    body_to_str.append((0, '{'))
    for enum_value in enum_data['values']:
        body_to_str.append((0, f'case {enum_class_name}::{to_pascal_case(enum_value)}:'))
        body_to_str.append((1, f'return "{enum_value}";'))
    body_to_str.append((0, 'default:'))
    body_to_str.append((1, 'return "unknown";'))
    body_to_str.append((0, '}'))

    body_to_enum : list[(int, str)] = []

    for enum_value in enum_data['values'][1:]:
        body_to_enum.append((0, f'if ( std::strcmp( str, "{enum_value}" ) == 0 )'))
        body_to_enum.append((0, '{'))
        body_to_enum.append((1, f'return {enum_class_name}::{to_pascal_case(enum_value)};'))
        body_to_enum.append((0, '}'))
    first_enum_value_name : str = to_pascal_case(enum_data['values'][0])
    body_to_enum.append((0, f'return {enum_class_name}::{first_enum_value_name};'))

    i = add_function_declaration(ls, i, 'to_c_str', 'char const *', [(enum_class_name, 'value')], is_noexcept=True, is_nodiscard=True, pre_qualifiers='inline', is_definition=True, body=body_to_str)
    add_blank(ls)
    i = add_function_declaration(ls, i, 'to_string', 'std::string', [(enum_class_name, 'value')], is_noexcept=True, is_nodiscard=True, pre_qualifiers='inline', is_definition=True, body=[(0, 'return std::string{ to_c_str( value ) };')])
    add_blank(ls)

    i = add_function_declaration(ls, i, f'to_{enum_data['name']}', enum_class_name, [('char const *', 'str')], is_noexcept=True, is_nodiscard=True, pre_qualifiers='inline', is_definition=True, body=body_to_enum)
    add_blank(ls)
    i = add_function_declaration(ls, i, f'to_{enum_data['name']}', enum_class_name, [('std::string const&', 'str')], is_noexcept=True, is_nodiscard=True, pre_qualifiers='inline', is_definition=True, body=[(0, f'return to_{enum_data["name"]}( str.c_str() );')])
    add_blank(ls)

    i = end_namespace(ls, i, *(['vortex', package_name] + namespace))

    add_blank(ls)
    i = add_line(ls, i, '#pragma clang diagnostic pop')


    create_file(path, ls)


def generate_enum_json_header_file(root_path: str, data: dict[str, Any], enum_data: dict[str, Any], ctx: dict[str, Any]) -> None:
    enum_class_name : str = _get_enum_class_name(enum_data)
    package_name : str = _get_package_name(data)
    namespace : list[str] = _get_namespace(data)
    path : str = get_header_path(enum_data['name'], package_name, namespace, root_path=root_path, suffix=JSON_INTEGRATION_SUFFIX)

    ls : list[str] = []
    i : int = 0

    i = add_block_comment(ls, i, '', 'Header file auto-generated by VORTEX SETTINGS WIZARD', '', 'TODO: Just testing', '')
    add_blank(ls)

    i = add_line(ls, i, '#pragma once')
    add_blank(ls)

    i = add_include(ls, i, 'nlohmann/json.hpp', is_quoted=False)
    add_blank(ls)

    i = add_include(ls, i, get_header_path(enum_data['name'], package_name, namespace, ctx='include'))
    add_blank(ls)

    i = begin_namespace(ls, i, *(['vortex', package_name] + namespace))
    add_blank(ls)

    i = add_line(ls, i, f'NLOHMANN_JSON_SERIALIZE_ENUM( {enum_class_name},')
    i = open_brace(ls, i)
    for enum_value in enum_data['values']:
        i = add_line(ls, i, '{ ' + enum_class_name + '::' + to_pascal_case(enum_value) + ', ' + f'"{enum_value}"' + ' },')
    i = close_brace(ls, i, suffix=')')

    add_blank(ls)
    i = end_namespace(ls, i, *(['vortex', package_name] + namespace))

    create_file(path, ls)


def generate_enum_source_file(root_path: str, data: dict[str, Any], enum_data: dict[str, Any], ctx: dict[str, Any]) -> None:
    enum_class_name : str = _get_enum_class_name(enum_data)
    package_name : str = _get_package_name(data)
    namespace : list[str] = _get_namespace(data)
    path : str = get_source_path(enum_data['name'], package_name, namespace, root_path=root_path)

    ls : list[str] = []
    i : int = 0

    i = add_block_comment(ls, i,'', 'Source file auto-generated by VORTEX SETTINGS WIZARD', '', 'TODO: Just testing', '')
    add_blank(ls)

    i = add_include(ls, i, get_header_path(enum_data['name'], package_name, namespace, ctx='include'))
    add_blank(ls)

    create_file(path, ls)


def generate_enum_unit_test_file(root_path: str, data: dict[str, Any], enum_data: dict[str, Any], ctx: dict[str, Any]) -> None:
    enum_class_name : str = _get_enum_class_name(enum_data)
    package_name : str = _get_package_name(data)
    namespace : list[str] = _get_namespace(data)
    path : str = get_unit_test_path(enum_data['name'], package_name, namespace, root_path=root_path)

    ls : list[str] = []
    i : int = 0

    i = add_block_comment(ls, i,'', 'Unit test source file auto-generated by VORTEX SETTINGS WIZARD', '', 'TODO: Just testing', '')
    add_blank(ls)

    i = add_include(ls, i, 'cstring', is_quoted=False)
    i = add_include(ls, i, 'string', is_quoted=False)
    i = add_include(ls, i, 'catch2/catch_test_macros.hpp', is_quoted=False)
    i = add_include(ls, i, 'nlohmann/json.hpp', is_quoted=False)
    i = add_include(ls, i, get_header_path(enum_data['name'], package_name, namespace, ctx='include'))
    i = add_include(ls, i, get_header_path(enum_data['name'], package_name, namespace, suffix=JSON_INTEGRATION_SUFFIX, ctx='include'))
    add_blank(ls)

    namespace_prefix : str = '::'.join(['vortex', package_name] + namespace) + '::'
    namespace_and_class_prefix : str = namespace_prefix + enum_class_name + '::'

    i = begin_test_case(ls, i, f'{enum_class_name} - conversion between enums and strings', 'sample')

    i = add_line(ls, i, 'using namespace std::string_literals;')
    add_blank(ls)

    for enum_value in enum_data['values']:
        enum_value_name = to_pascal_case(enum_value)
        i = add_block_comment(ls, i, f'Testing conversions for {enum_class_name}::{enum_value_name}')
        i = add_require(ls, i, f'{namespace_prefix}to_string( {namespace_and_class_prefix}{enum_value_name} ) == "{enum_value}"s')
        i = add_require(ls, i, f'std::strcmp( {namespace_prefix}to_c_str( {namespace_and_class_prefix}{enum_value_name} ), "{enum_value}" ) == 0')
        i = add_require(ls, i, f'{namespace_prefix}to_{enum_data['name']}( "{enum_value}" ) == {namespace_and_class_prefix}{enum_value_name}')
        i = add_require(ls, i, f'{namespace_prefix}to_{enum_data['name']}( "{enum_value}"s ) == {namespace_and_class_prefix}{enum_value_name}')
        i = add_require(ls, i, f'{namespace_prefix}to_{enum_data['name']}( {namespace_prefix}to_string( {namespace_and_class_prefix}{enum_value_name} ) ) == {namespace_and_class_prefix}{enum_value_name}')
        i = add_require(ls, i, f'{namespace_prefix}to_{enum_data['name']}( {namespace_prefix}to_c_str( {namespace_and_class_prefix}{enum_value_name} ) ) == {namespace_and_class_prefix}{enum_value_name}')
        add_blank(ls)

    invalid_index: int = len(enum_data['values'])
    default_enum_value_name: str = to_pascal_case(enum_data['values'][0])
    i = add_block_comment(ls, i, f'Testing conversions for values out of range')
    i = add_require(ls, i, f'{namespace_prefix}to_string( static_cast< {namespace_prefix}{enum_class_name} >( {invalid_index} ) ) == "unknown"s')
    i = add_require(ls, i, f'std::strcmp( {namespace_prefix}to_c_str( static_cast< {namespace_prefix}{enum_class_name} >( {invalid_index} ) ), "unknown" ) == 0')
    i = add_require(ls, i, f'{namespace_prefix}to_{enum_data['name']}( "" ) == {namespace_and_class_prefix}{default_enum_value_name}')
    i = add_require(ls, i, f'{namespace_prefix}to_{enum_data['name']}( ""s ) == {namespace_and_class_prefix}{default_enum_value_name}')

    i = end_test_case(ls, i)

    add_blank(ls, 2)
    i = begin_test_case(ls, i, f'{enum_class_name} - integration with json serialization', 'sample')

    for enum_value in enum_data['values']:
        i = add_line(ls, i, f'nlohmann::json {enum_value}_json_from_enum = {namespace_and_class_prefix}{to_pascal_case(enum_value)};')
        i = add_line(ls, i, f'nlohmann::json {enum_value}_json_from_str = "{enum_value}";')
    i = add_line(ls, i, 'nlohmann::json invalid_json_from_str = "unknown";')

    add_blank(ls)


    for enum_value in enum_data['values']:
        enum_value_name = to_pascal_case(enum_value)
        i = add_require(ls, i, f'{enum_value}_json_from_enum == "{enum_value}"')
        i = add_require(ls, i, f'{enum_value}_json_from_str == "{enum_value}"')
    i = add_require(ls, i, 'invalid_json_from_str == "unknown"')

    add_blank(ls)

    for enum_value in enum_data['values']:
        enum_value_name = to_pascal_case(enum_value)
        i = add_require(ls, i, f'{enum_value}_json_from_enum.template get< {namespace_prefix}{enum_class_name} >() == {namespace_and_class_prefix}{enum_value_name}')
        i = add_require(ls, i, f'{enum_value}_json_from_str.template get< {namespace_prefix}{enum_class_name} >() == {namespace_and_class_prefix}{enum_value_name}')
    i = add_require(ls, i, f'invalid_json_from_str.template get< {namespace_prefix}{enum_class_name} >() == {namespace_and_class_prefix}{to_pascal_case(enum_data["values"][0])}')

    i = end_test_case(ls, i)

    create_file(path, ls)


def populate_cmake_data(data: dict[str, Any], enum_data: dict[str, Any], ctx : dict[str, Any]) -> None:
    enum_class_name : str = _get_enum_class_name(enum_data)
    package_name : str = _get_package_name(data)
    namespace : list[str] = _get_namespace(data)

    if package_name not in ctx['cmake']:
        ctx['cmake'][package_name] : dict[str, dict[str, Any]] = {}
    pkg_data = ctx['cmake'][package_name]

    if 'headers' not in pkg_data:
        pkg_data['headers'] : dict[str, Any] = []
    pkg_data['headers'].append(get_header_path(enum_data['name'], package_name, namespace, ctx='cmake'))
    pkg_data['headers'].append(get_header_path(enum_data['name'], package_name, namespace, ctx='cmake', suffix=JSON_INTEGRATION_SUFFIX))

    if 'sources' not in pkg_data:
        pkg_data['sources'] : dict[str, Any] = []
    pkg_data['sources'].append(get_source_path(enum_data['name'], package_name, namespace, ctx='cmake'))

    if 'tests' not in pkg_data:
        pkg_data['tests'] : dict[str, Any] = []
    pkg_data['tests'].append(get_unit_test_path(enum_data['name'], package_name, namespace, ctx='cmake'))


def generate_enum(root_path: str, data: dict[str, Any], enum_data: dict[str, Any], ctx: dict[str, Any]) -> None:

    generate_enum_header_file(root_path, data, enum_data, ctx)
    generate_enum_json_header_file(root_path, data, enum_data, ctx)
    generate_enum_source_file(root_path, data, enum_data, ctx)
    generate_enum_unit_test_file(root_path, data, enum_data, ctx)

    populate_cmake_data(data, enum_data, ctx)
