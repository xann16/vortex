// 
// Header file auto-generated by VORTEX SETTINGS WIZARD
// 
// TODO: Just testing
// 

#pragma once

#include <ostream>

#include <nlohmann/json_fwd.hpp>

#include "core/common/types.hpp"
#include "core/settings/json/any_settings.hpp"
#include "runner/config/enums/parallel_strategy_type.hpp"

namespace vortex::runner::config
{

class TestCase
{
public:
    TestCase() noexcept = default;
    explicit TestCase( nlohmann::json * data_p );
    explicit TestCase( core::settings::json::AnySettings s )
    :   TestCase( s.data() )
    {}

public:

    [[nodiscard]] nlohmann::json * data() const noexcept
    {
        return m_data_p;
    }
    [[nodiscard]] bool is_empty() const noexcept
    {
        return data() == nullptr;
    }
    [[nodiscard]] core::settings::json::AnySettings as_any() const noexcept
    {
        return core::settings::json::AnySettings{ data() };
    }

    TestCase& update_with( nlohmann::json * other_data_p );
    TestCase& update_with( core::settings::json::AnySettings const& other )
    {
        return update_with( other.data() );
    }
    TestCase& update_with( TestCase const& other )
    {
        return update_with( other.data() );
    }

    [[nodiscard]] std::string to_string() const;
    std::ostream& stringify( std::ostream& os, int indent_size, int indent_level, bool display_all ) const;

    void validate();

    friend std::ostream& operator<<( std::ostream& os, TestCase const& s );

    friend bool operator==( TestCase const& lhs, TestCase const& rhs );
    friend bool operator!=( TestCase const& lhs, TestCase const& rhs )
    {
        return !( lhs == rhs );
    }

    // "name" property
    [[nodiscard]] std::string_view name() const;
    [[nodiscard]] bool has_name_set() const noexcept;
    [[nodiscard]] constexpr std::string_view default_name() const noexcept
    {
        return std::string_view{};
    }
    void reset_name();
    void set_name( std::string const& name );
    void set_name( std::string && name );
    void set_name( std::string_view name )
    {
        set_name( std::string{ name } );
    }
    void set_name( char const * name )
    {
        set_name( std::string{ name } );
    }

    // "template_name" property
    [[nodiscard]] std::string_view template_name() const;
    [[nodiscard]] bool has_template_name_set() const noexcept;
    [[nodiscard]] constexpr std::string_view default_template_name() const noexcept
    {
        return std::string_view{};
    }
    void reset_template_name();
    void set_template_name( std::string const& template_name );
    void set_template_name( std::string && template_name );
    void set_template_name( std::string_view template_name )
    {
        set_template_name( std::string{ template_name } );
    }
    void set_template_name( char const * template_name )
    {
        set_template_name( std::string{ template_name } );
    }

    // "settings" property
    [[nodiscard]] core::settings::json::AnySettings settings() const;
    [[nodiscard]] bool has_settings_set() const noexcept;
    [[nodiscard]] constexpr core::settings::json::AnySettings default_settings() const noexcept
    {
        return core::settings::json::AnySettings{};
    }
    void reset_settings();
    void set_settings( core::settings::json::AnySettings settings );

    // "parallel_strategy" property
    [[nodiscard]] ParallelStrategyType parallel_strategy() const;
    [[nodiscard]] bool has_parallel_strategy_set() const noexcept;
    [[nodiscard]] constexpr ParallelStrategyType default_parallel_strategy() const noexcept
    {
        return ParallelStrategyType::Mmx;
    }
    void reset_parallel_strategy();
    void set_parallel_strategy( ParallelStrategyType parallel_strategy );

    // "stages" property
    [[nodiscard]] std::vector< std::string > stages() const;
    [[nodiscard]] bool has_stages_set() const noexcept;
    [[nodiscard]] std::vector< std::string > default_stages() const noexcept
    {
        return std::vector< std::string >{};
    }
    void reset_stages();
    void set_stages( std::vector< std::string > const& stages );
    void set_stages( std::vector< std::string > && stages );
    void set_stages( std::initializer_list< std::string > stages_list );
    [[nodiscard]] bool are_stages_empty() const noexcept;
    [[nodiscard]] std::size_t stages_count() const noexcept;
    void clear_stages();
    [[nodiscard]] std::string_view stage_at( std::size_t index ) const;
    void add_stage( std::string const& stage );
    void add_stage( std::string && stage );
    void add_stage( std::string_view stage )
    {
        add_stage( std::string{ stage } );
    }
    void add_stage( char const * stage )
    {
        add_stage( std::string{ stage } );
    }
    void remove_stage_at( std::size_t index );
    void remove_stage( std::string const& stage );
    void remove_stage( std::string && stage );
    void remove_stage( std::string_view stage )
    {
        remove_stage( std::string{ stage } );
    }
    void remove_stage( char const * stage )
    {
        remove_stage( std::string{ stage } );
    }

    // "process_count" property
    [[nodiscard]] i32 process_count() const;
    [[nodiscard]] bool has_process_count_set() const noexcept;
    [[nodiscard]] constexpr i32 default_process_count() const noexcept
    {
        return 1;
    }
    void reset_process_count();
    void set_process_count( i32 process_count );


private:
    void pre_validate_all();
    static void pre_validate_name( [[maybe_unused]] std::string_view name );
    static void pre_validate_template_name( [[maybe_unused]] std::string_view template_name );
    static void pre_validate_settings( [[maybe_unused]] core::settings::json::AnySettings settings );
    static void pre_validate_parallel_strategy( [[maybe_unused]] ParallelStrategyType parallel_strategy );
    static void pre_validate_stages( [[maybe_unused]] std::vector< std::string > const& stages );
    static void pre_validate_stage( [[maybe_unused]] std::string_view stage );
    static void pre_validate_process_count( [[maybe_unused]] i32 process_count );

private:
    nlohmann::json * m_data_p = nullptr;
}; // end of class TestCase

} // end of namespace vortex::runner::config
