// 
// Source file auto-generated by VORTEX SETTINGS WIZARD
// 
// TODO: Just testing
// 

#include "turb/legacy/settings/execution_settings.hpp"

#include <iomanip>
#include <sstream>

#include <nlohmann/json.hpp>


namespace vortex::turb::legacy::settings
{

ExecutionSettings::ExecutionSettings( nlohmann::json * data_p )
:   m_data_p( data_p )
{
    pre_validate_all();
}

ExecutionSettings& ExecutionSettings::update_with( nlohmann::json * other_data_p )
{
    if (!is_empty() && other_data_p != nullptr)
    {
        as_any().update_with( other_data_p );
        pre_validate_all();
    }
    return *this;
}

[[nodiscard]] std::string ExecutionSettings::to_string() const
{
    auto oss = std::ostringstream{};
    oss << *this;
    return oss.str();
}

std::ostream& ExecutionSettings::stringify( std::ostream& os, int indent_size, int indent_level, bool display_all ) const
{
    if ( !display_all && ( is_empty() || data()->empty() ) )
    {
        os << "<empty>\n"; 
        return os;
    }
    
    if ( display_all || has_job_name_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "job_name: " << job_name() << '\n';
    }
    if ( display_all || has_grant_no_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "grant_no: " << grant_no() << '\n';
    }
    if ( display_all || has_cpu_node_count_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "cpu_node_count: " << cpu_node_count() << '\n';
    }
    if ( display_all || has_wct_limit_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "wct_limit: " << wct_limit() << '\n';
    }
    if ( display_all || has_process_count_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "process_count: " << process_count() << '\n';
    }
    if ( display_all || has_is_node_overcommit_enabled_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "is_node_overcommit_enabled: " << ( is_node_overcommit_enabled() ? "true" : "false" ) << '\n';
    }
    
    return os;
}

void ExecutionSettings::validate()
{}

void ExecutionSettings::pre_validate_all()
{
    if ( is_empty() ) return;
    
    if ( has_job_name_set() )
    {
        pre_validate_job_name( job_name() );
    }
    if ( has_grant_no_set() )
    {
        pre_validate_grant_no( grant_no() );
    }
    if ( has_cpu_node_count_set() )
    {
        pre_validate_cpu_node_count( cpu_node_count() );
    }
    if ( has_wct_limit_set() )
    {
        pre_validate_wct_limit( wct_limit() );
    }
    if ( has_process_count_set() )
    {
        pre_validate_process_count( process_count() );
    }
    if ( has_is_node_overcommit_enabled_set() )
    {
        pre_validate_is_node_overcommit_enabled( is_node_overcommit_enabled() );
    }
}

std::ostream& operator<<( std::ostream& os, ExecutionSettings const& s )
{
    return s.stringify( os, 2, 0, os.flags() & std::ios_base::boolalpha );
}

bool operator==( ExecutionSettings const& lhs, ExecutionSettings const& rhs )
{
    return lhs.is_empty()
        ? rhs.is_empty()
        : ( !rhs.is_empty() && *lhs.data() == *rhs.data() );
}

// "job_name" property

[[nodiscard]] std::string_view ExecutionSettings::job_name() const
{
    if ( is_empty() ) return default_job_name();
    auto it = data()->find( "job_name" );
    if ( it == data()->end() || it->is_null() ) return default_job_name();
    return std::string_view{ it->template get_ref<std::string const&>() };
}

[[nodiscard]] bool ExecutionSettings::has_job_name_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "job_name" );
    return it != data()->end() && !it->is_null();
}

void ExecutionSettings::reset_job_name()
{
    if ( is_empty() ) return;
    data()->erase( "job_name" );
}

void ExecutionSettings::set_job_name( std::string const& job_name )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"job_name\". Object is empty." };
    pre_validate_job_name( job_name );
    data()->operator[]( "job_name" ) = job_name;
}
void ExecutionSettings::set_job_name( std::string && job_name )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"job_name\". Object is empty." };
    pre_validate_job_name( job_name );
    data()->operator[]( "job_name" ) = job_name;
}

void ExecutionSettings::pre_validate_job_name( [[maybe_unused]] std::string_view job_name )
{
    if ( job_name.empty() )
    {
        throw std::runtime_error{ "Validation failed for property 'job_name': Value is empty." };
    }
    
}

// "grant_no" property

[[nodiscard]] std::string_view ExecutionSettings::grant_no() const
{
    if ( is_empty() ) return default_grant_no();
    auto it = data()->find( "grant_no" );
    if ( it == data()->end() || it->is_null() ) return default_grant_no();
    return std::string_view{ it->template get_ref<std::string const&>() };
}

[[nodiscard]] bool ExecutionSettings::has_grant_no_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "grant_no" );
    return it != data()->end() && !it->is_null();
}

void ExecutionSettings::reset_grant_no()
{
    if ( is_empty() ) return;
    data()->erase( "grant_no" );
}

void ExecutionSettings::set_grant_no( std::string const& grant_no )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"grant_no\". Object is empty." };
    pre_validate_grant_no( grant_no );
    data()->operator[]( "grant_no" ) = grant_no;
}
void ExecutionSettings::set_grant_no( std::string && grant_no )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"grant_no\". Object is empty." };
    pre_validate_grant_no( grant_no );
    data()->operator[]( "grant_no" ) = grant_no;
}

void ExecutionSettings::pre_validate_grant_no( [[maybe_unused]] std::string_view grant_no )
{
    if ( grant_no.empty() )
    {
        throw std::runtime_error{ "Validation failed for property 'grant_no': Value is empty." };
    }
    
}

// "cpu_node_count" property

[[nodiscard]] i32 ExecutionSettings::cpu_node_count() const
{
    if ( is_empty() ) return default_cpu_node_count();
    auto it = data()->find( "cpu_node_count" );
    if ( it == data()->end() || it->is_null() ) return default_cpu_node_count();
    return it->template get< i32 >();
}

[[nodiscard]] bool ExecutionSettings::has_cpu_node_count_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "cpu_node_count" );
    return it != data()->end() && !it->is_null();
}

void ExecutionSettings::reset_cpu_node_count()
{
    if ( is_empty() ) return;
    data()->erase( "cpu_node_count" );
}

void ExecutionSettings::set_cpu_node_count( i32 cpu_node_count )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"cpu_node_count\". Object is empty." };
    pre_validate_cpu_node_count( cpu_node_count );
    data()->operator[]( "cpu_node_count" ) = cpu_node_count;
}

void ExecutionSettings::pre_validate_cpu_node_count( [[maybe_unused]] i32 cpu_node_count )
{
    auto value = cpu_node_count;
    if ( value < 1 )
    {
        throw std::runtime_error{ "Validation failed for property 'cpu_node_count': Value is not within required range." };
    }
    
}

// "wct_limit" property

[[nodiscard]] f64 ExecutionSettings::wct_limit() const
{
    if ( is_empty() ) return default_wct_limit();
    auto it = data()->find( "wct_limit" );
    if ( it == data()->end() || it->is_null() ) return default_wct_limit();
    return it->template get< f64 >();
}

[[nodiscard]] bool ExecutionSettings::has_wct_limit_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "wct_limit" );
    return it != data()->end() && !it->is_null();
}

void ExecutionSettings::reset_wct_limit()
{
    if ( is_empty() ) return;
    data()->erase( "wct_limit" );
}

void ExecutionSettings::set_wct_limit( f64 wct_limit )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"wct_limit\". Object is empty." };
    pre_validate_wct_limit( wct_limit );
    data()->operator[]( "wct_limit" ) = wct_limit;
}

void ExecutionSettings::pre_validate_wct_limit( [[maybe_unused]] f64 wct_limit )
{
    auto value = wct_limit;
    if ( value < 5.0 )
    {
        throw std::runtime_error{ "Validation failed for property 'wct_limit': Value is not within required range." };
    }
    
}

// "process_count" property

[[nodiscard]] i32 ExecutionSettings::process_count() const
{
    if ( is_empty() ) return default_process_count();
    auto it = data()->find( "process_count" );
    if ( it == data()->end() || it->is_null() ) return default_process_count();
    return it->template get< i32 >();
}

[[nodiscard]] bool ExecutionSettings::has_process_count_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "process_count" );
    return it != data()->end() && !it->is_null();
}

void ExecutionSettings::reset_process_count()
{
    if ( is_empty() ) return;
    data()->erase( "process_count" );
}

void ExecutionSettings::set_process_count( i32 process_count )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"process_count\". Object is empty." };
    pre_validate_process_count( process_count );
    data()->operator[]( "process_count" ) = process_count;
}

void ExecutionSettings::pre_validate_process_count( [[maybe_unused]] i32 process_count )
{
    auto value = process_count;
    if ( value < 1 )
    {
        throw std::runtime_error{ "Validation failed for property 'process_count': Value is not within required range." };
    }
    
}

// "is_node_overcommit_enabled" property

[[nodiscard]] bool ExecutionSettings::is_node_overcommit_enabled() const
{
    if ( is_empty() ) return default_is_node_overcommit_enabled();
    auto it = data()->find( "is_node_overcommit_enabled" );
    if ( it == data()->end() || it->is_null() ) return default_is_node_overcommit_enabled();
    return it->template get< bool >();
}

[[nodiscard]] bool ExecutionSettings::has_is_node_overcommit_enabled_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "is_node_overcommit_enabled" );
    return it != data()->end() && !it->is_null();
}

void ExecutionSettings::reset_is_node_overcommit_enabled()
{
    if ( is_empty() ) return;
    data()->erase( "is_node_overcommit_enabled" );
}

void ExecutionSettings::set_is_node_overcommit_enabled( bool is_node_overcommit_enabled )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"is_node_overcommit_enabled\". Object is empty." };
    pre_validate_is_node_overcommit_enabled( is_node_overcommit_enabled );
    data()->operator[]( "is_node_overcommit_enabled" ) = is_node_overcommit_enabled;
}

void ExecutionSettings::pre_validate_is_node_overcommit_enabled( [[maybe_unused]] bool is_node_overcommit_enabled )
{}


} // end of namespace vortex::turb::legacy::settings
