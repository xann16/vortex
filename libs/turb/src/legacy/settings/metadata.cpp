// 
// Source file auto-generated by VORTEX SETTINGS WIZARD
// 
// TODO: Just testing
// 

#include "turb/legacy/settings/metadata.hpp"

#include <nlohmann/json.hpp>

#include "turb/legacy/settings/enums/sim_method_json_integration.hpp"
#include "turb/legacy/settings/enums/particle_mode_json_integration.hpp"
#include "turb/legacy/settings/enums/gravity_mode_json_integration.hpp"
#include "turb/legacy/settings/enums/particle_twc_kernel_type_json_integration.hpp"

namespace vortex::turb::legacy::settings
{

Metadata::Metadata( nlohmann::json * data_p )
:   m_data_p( data_p )
{
    // add initial validation
}

// "sim_method" property

[[nodiscard]] SimMethod Metadata::sim_method() const
{
    if ( m_data_p == nullptr ) return default_sim_method();
    auto it = m_data_p->find( "sim_method" );
    if ( it == m_data_p->end() || it->is_null() ) return default_sim_method();
    return it->template get<SimMethod>();
}

// "particle_mode" property

[[nodiscard]] ParticleMode Metadata::particle_mode() const
{
    if ( m_data_p == nullptr ) return default_particle_mode();
    auto it = m_data_p->find( "particle_mode" );
    if ( it == m_data_p->end() || it->is_null() ) return default_particle_mode();
    return it->template get<ParticleMode>();
}

// "gravity_type" property

[[nodiscard]] GravityMode Metadata::gravity_type() const
{
    if ( m_data_p == nullptr ) return default_gravity_type();
    auto it = m_data_p->find( "gravity_type" );
    if ( it == m_data_p->end() || it->is_null() ) return default_gravity_type();
    return it->template get<GravityMode>();
}

// "particle_kernel_type" property

[[nodiscard]] ParticleTwcKernelType Metadata::particle_kernel_type() const
{
    if ( m_data_p == nullptr ) return default_particle_kernel_type();
    auto it = m_data_p->find( "particle_kernel_type" );
    if ( it == m_data_p->end() || it->is_null() ) return default_particle_kernel_type();
    return it->template get<ParticleTwcKernelType>();
}

// "k_filter" property

[[nodiscard]] i32 Metadata::k_filter() const
{
    if ( m_data_p == nullptr ) return default_k_filter();
    auto it = m_data_p->find( "k_filter" );
    if ( it == m_data_p->end() || it->is_null() ) return default_k_filter();
    return it->template get<i32>();
}

// "C_K" property

[[nodiscard]] real Metadata::C_K() const
{
    if ( m_data_p == nullptr ) return default_C_K();
    auto it = m_data_p->find( "C_K" );
    if ( it == m_data_p->end() || it->is_null() ) return default_C_K();
    return it->template get<real>();
}

// "target_Phi" property

[[nodiscard]] real Metadata::target_Phi() const
{
    if ( m_data_p == nullptr ) return default_target_Phi();
    auto it = m_data_p->find( "target_Phi" );
    if ( it == m_data_p->end() || it->is_null() ) return default_target_Phi();
    return it->template get<real>();
}

// "superpart_factor" property

[[nodiscard]] real Metadata::superpart_factor() const
{
    if ( m_data_p == nullptr ) return default_superpart_factor();
    auto it = m_data_p->find( "superpart_factor" );
    if ( it == m_data_p->end() || it->is_null() ) return default_superpart_factor();
    return it->template get<real>();
}

// "src_flow_path" property

[[nodiscard]] std::string_view Metadata::src_flow_path() const
{
    if ( m_data_p == nullptr ) return default_src_flow_path();
    auto it = m_data_p->find( "src_flow_path" );
    if ( it == m_data_p->end() || it->is_null() ) return default_src_flow_path();
    return std::string_view{ it->template get_ref<std::string const&>() };
}

// "src_part_path" property

[[nodiscard]] std::string_view Metadata::src_part_path() const
{
    if ( m_data_p == nullptr ) return default_src_part_path();
    auto it = m_data_p->find( "src_part_path" );
    if ( it == m_data_p->end() || it->is_null() ) return default_src_part_path();
    return std::string_view{ it->template get_ref<std::string const&>() };
}

// "part_output_delay" property

[[nodiscard]] i32 Metadata::part_output_delay() const
{
    if ( m_data_p == nullptr ) return default_part_output_delay();
    auto it = m_data_p->find( "part_output_delay" );
    if ( it == m_data_p->end() || it->is_null() ) return default_part_output_delay();
    return it->template get<i32>();
}

// "is_perf_full_profile_enabled" property

[[nodiscard]] bool Metadata::is_perf_full_profile_enabled() const
{
    if ( m_data_p == nullptr ) return default_is_perf_full_profile_enabled();
    auto it = m_data_p->find( "is_perf_full_profile_enabled" );
    if ( it == m_data_p->end() || it->is_null() ) return default_is_perf_full_profile_enabled();
    return it->template get<bool>();
}

// "is_perf_simple_enabled" property

[[nodiscard]] bool Metadata::is_perf_simple_enabled() const
{
    if ( m_data_p == nullptr ) return default_is_perf_simple_enabled();
    auto it = m_data_p->find( "is_perf_simple_enabled" );
    if ( it == m_data_p->end() || it->is_null() ) return default_is_perf_simple_enabled();
    return it->template get<bool>();
}

// "is_perf_part_dist_enabled" property

[[nodiscard]] bool Metadata::is_perf_part_dist_enabled() const
{
    if ( m_data_p == nullptr ) return default_is_perf_part_dist_enabled();
    auto it = m_data_p->find( "is_perf_part_dist_enabled" );
    if ( it == m_data_p->end() || it->is_null() ) return default_is_perf_part_dist_enabled();
    return it->template get<bool>();
}

// "perf_full_start" property

[[nodiscard]] i32 Metadata::perf_full_start() const
{
    if ( m_data_p == nullptr ) return default_perf_full_start();
    auto it = m_data_p->find( "perf_full_start" );
    if ( it == m_data_p->end() || it->is_null() ) return default_perf_full_start();
    return it->template get<i32>();
}

// "perf_full_end" property

[[nodiscard]] i32 Metadata::perf_full_end() const
{
    if ( m_data_p == nullptr ) return default_perf_full_end();
    auto it = m_data_p->find( "perf_full_end" );
    if ( it == m_data_p->end() || it->is_null() ) return default_perf_full_end();
    return it->template get<i32>();
}

// "part_perf_interval" property

[[nodiscard]] i32 Metadata::part_perf_interval() const
{
    if ( m_data_p == nullptr ) return default_part_perf_interval();
    auto it = m_data_p->find( "part_perf_interval" );
    if ( it == m_data_p->end() || it->is_null() ) return default_part_perf_interval();
    return it->template get<i32>();
}


} // end of namespace vortex::turb::legacy::settings
