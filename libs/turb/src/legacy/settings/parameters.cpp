// 
// Source file auto-generated by VORTEX SETTINGS WIZARD
// 
// TODO: Just testing
// 

#include "turb/legacy/settings/parameters.hpp"

#include <iomanip>
#include <sstream>

#include <nlohmann/json.hpp>

#include "turb/legacy/settings/enums/forcing_type_json_integration.hpp"
#include "turb/legacy/settings/enums/drag_type_json_integration.hpp"

namespace vortex::turb::legacy::settings
{

Parameters::Parameters( nlohmann::json * data_p )
:   m_data_p( data_p )
{
    pre_validate_all();
}

Parameters& Parameters::update_with( nlohmann::json * other_data_p )
{
    if (!is_empty() && other_data_p != nullptr)
    {
        as_any().update_with( other_data_p );
        pre_validate_all();
    }
    return *this;
}

[[nodiscard]] std::string Parameters::to_string() const
{
    auto oss = std::ostringstream{};
    oss << *this;
    return oss.str();
}

std::ostream& Parameters::stringify( std::ostream& os, int indent_size, int indent_level, bool display_all ) const
{
    if ( !display_all && ( is_empty() || data()->empty() ) )
    {
        os << "<empty>\n"; 
        return os;
    }
    
    if ( display_all || has_N_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "N: " << N() << '\n';
    }
    if ( display_all || has_N_subdomain_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "N_subdomain: " << N_subdomain() << '\n';
    }
    if ( display_all || has_Nt_max_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "Nt_max: " << Nt_max() << '\n';
    }
    if ( display_all || has_dt_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "dt: " << dt() << '\n';
    }
    if ( display_all || has_rnu_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "rnu: " << rnu() << '\n';
    }
    if ( display_all || has_t_init_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "t_init: " << t_init() << '\n';
    }
    if ( display_all || has_is_flow_generated_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "is_flow_generated: " << ( is_flow_generated() ? "true" : "false" ) << '\n';
    }
    if ( display_all || has_deterministic_seed_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "deterministic_seed: " << deterministic_seed() << '\n';
    }
    if ( display_all || has_input_velo_index_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "input_velo_index: " << input_velo_index() << '\n';
    }
    if ( display_all || has_forcing_type_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "forcing_type: " << to_c_str( forcing_type() ) << '\n';
    }
    if ( display_all || has_deterministic_forcing_k_1_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "deterministic_forcing_k_1: " << deterministic_forcing_k_1() << '\n';
    }
    if ( display_all || has_deterministic_forcing_k_2_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "deterministic_forcing_k_2: " << deterministic_forcing_k_2() << '\n';
    }
    if ( display_all || has_stochastic_seed_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "stochastic_seed: " << stochastic_seed() << '\n';
    }
    if ( display_all || has_stats_output_interval_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "stats_output_interval: " << stats_output_interval() << '\n';
    }
    if ( display_all || has_spectrum_output_interval_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "spectrum_output_interval: " << spectrum_output_interval() << '\n';
    }
    if ( display_all || has_is_stats_output_extended_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "is_stats_output_extended: " << ( is_stats_output_extended() ? "true" : "false" ) << '\n';
    }
    if ( display_all || has_rho_part_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "rho_part: " << rho_part() << '\n';
    }
    if ( display_all || has_rho_fluid_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "rho_fluid: " << rho_fluid() << '\n';
    }
    if ( display_all || has_eta_k_init_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "eta_k_init: " << eta_k_init() << '\n';
    }
    if ( display_all || has_tau_k_init_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "tau_k_init: " << tau_k_init() << '\n';
    }
    if ( display_all || has_shell_thickness_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "shell_thickness: " << shell_thickness() << '\n';
    }
    if ( display_all || has_epsilon_env_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "epsilon_env: " << epsilon_env() << '\n';
    }
    if ( display_all || has_nu_fluid_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "nu_fluid: " << nu_fluid() << '\n';
    }
    if ( display_all || has_gravity_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "gravity: " << gravity() << '\n';
    }
    if ( display_all || has_is_part_generated_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "is_part_generated: " << ( is_part_generated() ? "true" : "false" ) << '\n';
    }
    if ( display_all || has_is_part_overlapping_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "is_part_overlapping: " << ( is_part_overlapping() ? "true" : "false" ) << '\n';
    }
    if ( display_all || has_is_part_hdi_enabled_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "is_part_hdi_enabled: " << ( is_part_hdi_enabled() ? "true" : "false" ) << '\n';
    }
    if ( display_all || has_part_hdi_trunc_enabled_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "part_hdi_trunc_enabled: " << part_hdi_trunc_enabled() << '\n';
    }
    if ( display_all || has_N_part_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "N_part: " << N_part() << '\n';
    }
    if ( display_all || has_drag_type_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "drag_type: " << to_c_str( drag_type() ) << '\n';
    }
    if ( display_all || has_a_set() )
    {
        os << std::setw( indent_size * indent_level ) << "" << "a: " << a() << '\n';
    }
    
    return os;
}

void Parameters::validate() const
{
    if ( has_N_subdomain_set() )
    {
        auto N_subdomain_value = N_subdomain();
        auto value = N_subdomain_value;
        if ( value > N() )
        {
            throw std::runtime_error{ "Validation failed for property 'N_subdomain': Value is not within required range." };
        }
    }
    
}

void Parameters::pre_validate_all()
{
    if ( is_empty() ) return;
    
    if ( has_N_set() )
    {
        pre_validate_N( N() );
    }
    if ( has_N_subdomain_set() )
    {
        pre_validate_N_subdomain( N_subdomain() );
    }
    if ( has_Nt_max_set() )
    {
        pre_validate_Nt_max( Nt_max() );
    }
    if ( has_dt_set() )
    {
        pre_validate_dt( dt() );
    }
    if ( has_rnu_set() )
    {
        pre_validate_rnu( rnu() );
    }
    if ( has_t_init_set() )
    {
        pre_validate_t_init( t_init() );
    }
    if ( has_is_flow_generated_set() )
    {
        pre_validate_is_flow_generated( is_flow_generated() );
    }
    if ( has_deterministic_seed_set() )
    {
        pre_validate_deterministic_seed( deterministic_seed() );
    }
    if ( has_input_velo_index_set() )
    {
        pre_validate_input_velo_index( input_velo_index() );
    }
    if ( has_forcing_type_set() )
    {
        pre_validate_forcing_type( forcing_type() );
    }
    if ( has_deterministic_forcing_k_1_set() )
    {
        pre_validate_deterministic_forcing_k_1( deterministic_forcing_k_1() );
    }
    if ( has_deterministic_forcing_k_2_set() )
    {
        pre_validate_deterministic_forcing_k_2( deterministic_forcing_k_2() );
    }
    if ( has_stochastic_seed_set() )
    {
        pre_validate_stochastic_seed( stochastic_seed() );
    }
    if ( has_stats_output_interval_set() )
    {
        pre_validate_stats_output_interval( stats_output_interval() );
    }
    if ( has_spectrum_output_interval_set() )
    {
        pre_validate_spectrum_output_interval( spectrum_output_interval() );
    }
    if ( has_is_stats_output_extended_set() )
    {
        pre_validate_is_stats_output_extended( is_stats_output_extended() );
    }
    if ( has_rho_part_set() )
    {
        pre_validate_rho_part( rho_part() );
    }
    if ( has_rho_fluid_set() )
    {
        pre_validate_rho_fluid( rho_fluid() );
    }
    if ( has_eta_k_init_set() )
    {
        pre_validate_eta_k_init( eta_k_init() );
    }
    if ( has_tau_k_init_set() )
    {
        pre_validate_tau_k_init( tau_k_init() );
    }
    if ( has_shell_thickness_set() )
    {
        pre_validate_shell_thickness( shell_thickness() );
    }
    if ( has_epsilon_env_set() )
    {
        pre_validate_epsilon_env( epsilon_env() );
    }
    if ( has_nu_fluid_set() )
    {
        pre_validate_nu_fluid( nu_fluid() );
    }
    if ( has_gravity_set() )
    {
        pre_validate_gravity( gravity() );
    }
    if ( has_is_part_generated_set() )
    {
        pre_validate_is_part_generated( is_part_generated() );
    }
    if ( has_is_part_overlapping_set() )
    {
        pre_validate_is_part_overlapping( is_part_overlapping() );
    }
    if ( has_is_part_hdi_enabled_set() )
    {
        pre_validate_is_part_hdi_enabled( is_part_hdi_enabled() );
    }
    if ( has_part_hdi_trunc_enabled_set() )
    {
        pre_validate_part_hdi_trunc_enabled( part_hdi_trunc_enabled() );
    }
    if ( has_N_part_set() )
    {
        pre_validate_N_part( N_part() );
    }
    if ( has_drag_type_set() )
    {
        pre_validate_drag_type( drag_type() );
    }
    if ( has_a_set() )
    {
        pre_validate_a( a() );
    }
}

std::ostream& operator<<( std::ostream& os, Parameters const& s )
{
    return s.stringify( os, 2, 0, os.flags() & std::ios_base::boolalpha );
}

bool operator==( Parameters const& lhs, Parameters const& rhs )
{
    return lhs.is_empty()
        ? rhs.is_empty()
        : ( !rhs.is_empty() && *lhs.data() == *rhs.data() );
}

// "N" property

[[nodiscard]] i32 Parameters::N() const
{
    if ( is_empty() ) return default_N();
    auto it = data()->find( "N" );
    if ( it == data()->end() || it->is_null() ) return default_N();
    return it->template get< i32 >();
}

[[nodiscard]] bool Parameters::has_N_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "N" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_N()
{
    if ( is_empty() ) return;
    data()->erase( "N" );
}

void Parameters::set_N( i32 N )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"N\". Object is empty." };
    pre_validate_N( N );
    data()->operator[]( "N" ) = N;
}

void Parameters::pre_validate_N( [[maybe_unused]] i32 N )
{
    auto value = N;
    if ( value < 8 )
    {
        throw std::runtime_error{ "Validation failed for property 'N': Value is not within required range." };
    }
    
    auto v = N;
    if ( v == 0 || ( v & ( v - 1 ) ) != 0 )
    {
        throw std::runtime_error{ "Validation failed for property 'N': Value is not a power of 2." };
    }
    
}

// "N_subdomain" property

[[nodiscard]] i32 Parameters::N_subdomain() const
{
    if ( is_empty() ) return default_N_subdomain();
    auto it = data()->find( "N_subdomain" );
    if ( it == data()->end() || it->is_null() ) return default_N_subdomain();
    return it->template get< i32 >();
}

[[nodiscard]] bool Parameters::has_N_subdomain_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "N_subdomain" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_N_subdomain()
{
    if ( is_empty() ) return;
    data()->erase( "N_subdomain" );
}

void Parameters::set_N_subdomain( i32 N_subdomain )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"N_subdomain\". Object is empty." };
    pre_validate_N_subdomain( N_subdomain );
    data()->operator[]( "N_subdomain" ) = N_subdomain;
}

void Parameters::pre_validate_N_subdomain( [[maybe_unused]] i32 N_subdomain )
{
    auto value = N_subdomain;
    if ( value < 1 )
    {
        throw std::runtime_error{ "Validation failed for property 'N_subdomain': Value is not within required range." };
    }
    
    auto v = N_subdomain;
    if ( v == 0 || ( v & ( v - 1 ) ) != 0 )
    {
        throw std::runtime_error{ "Validation failed for property 'N_subdomain': Value is not a power of 2." };
    }
    
}

// "Nt_max" property

[[nodiscard]] i32 Parameters::Nt_max() const
{
    if ( is_empty() ) return default_Nt_max();
    auto it = data()->find( "Nt_max" );
    if ( it == data()->end() || it->is_null() ) return default_Nt_max();
    return it->template get< i32 >();
}

[[nodiscard]] bool Parameters::has_Nt_max_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "Nt_max" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_Nt_max()
{
    if ( is_empty() ) return;
    data()->erase( "Nt_max" );
}

void Parameters::set_Nt_max( i32 Nt_max )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"Nt_max\". Object is empty." };
    pre_validate_Nt_max( Nt_max );
    data()->operator[]( "Nt_max" ) = Nt_max;
}

void Parameters::pre_validate_Nt_max( [[maybe_unused]] i32 Nt_max )
{
    auto value = Nt_max;
    if ( value < 1 )
    {
        throw std::runtime_error{ "Validation failed for property 'Nt_max': Value is not within required range." };
    }
    
}

// "dt" property

[[nodiscard]] real Parameters::dt() const
{
    if ( is_empty() ) return default_dt();
    auto it = data()->find( "dt" );
    if ( it == data()->end() || it->is_null() ) return default_dt();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_dt_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "dt" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_dt()
{
    if ( is_empty() ) return;
    data()->erase( "dt" );
}

void Parameters::set_dt( real dt )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"dt\". Object is empty." };
    pre_validate_dt( dt );
    data()->operator[]( "dt" ) = dt;
}

void Parameters::pre_validate_dt( [[maybe_unused]] real dt )
{
    auto value = dt;
    if ( value < 0.0 )
    {
        throw std::runtime_error{ "Validation failed for property 'dt': Value is not within required range." };
    }
    
}

// "rnu" property

[[nodiscard]] real Parameters::rnu() const
{
    if ( is_empty() ) return default_rnu();
    auto it = data()->find( "rnu" );
    if ( it == data()->end() || it->is_null() ) return default_rnu();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_rnu_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "rnu" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_rnu()
{
    if ( is_empty() ) return;
    data()->erase( "rnu" );
}

void Parameters::set_rnu( real rnu )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"rnu\". Object is empty." };
    pre_validate_rnu( rnu );
    data()->operator[]( "rnu" ) = rnu;
}

void Parameters::pre_validate_rnu( [[maybe_unused]] real rnu )
{
    auto value = rnu;
    if ( value < 0.0 )
    {
        throw std::runtime_error{ "Validation failed for property 'rnu': Value is not within required range." };
    }
    
}

// "t_init" property

[[nodiscard]] real Parameters::t_init() const
{
    if ( is_empty() ) return default_t_init();
    auto it = data()->find( "t_init" );
    if ( it == data()->end() || it->is_null() ) return default_t_init();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_t_init_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "t_init" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_t_init()
{
    if ( is_empty() ) return;
    data()->erase( "t_init" );
}

void Parameters::set_t_init( real t_init )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"t_init\". Object is empty." };
    pre_validate_t_init( t_init );
    data()->operator[]( "t_init" ) = t_init;
}

void Parameters::pre_validate_t_init( [[maybe_unused]] real t_init )
{}

// "is_flow_generated" property

[[nodiscard]] bool Parameters::is_flow_generated() const
{
    if ( is_empty() ) return default_is_flow_generated();
    auto it = data()->find( "is_flow_generated" );
    if ( it == data()->end() || it->is_null() ) return default_is_flow_generated();
    return it->template get< bool >();
}

[[nodiscard]] bool Parameters::has_is_flow_generated_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "is_flow_generated" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_is_flow_generated()
{
    if ( is_empty() ) return;
    data()->erase( "is_flow_generated" );
}

void Parameters::set_is_flow_generated( bool is_flow_generated )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"is_flow_generated\". Object is empty." };
    pre_validate_is_flow_generated( is_flow_generated );
    data()->operator[]( "is_flow_generated" ) = is_flow_generated;
}

void Parameters::pre_validate_is_flow_generated( [[maybe_unused]] bool is_flow_generated )
{}

// "deterministic_seed" property

[[nodiscard]] u64 Parameters::deterministic_seed() const
{
    if ( is_empty() ) return default_deterministic_seed();
    auto it = data()->find( "deterministic_seed" );
    if ( it == data()->end() || it->is_null() ) return default_deterministic_seed();
    return it->template get< u64 >();
}

[[nodiscard]] bool Parameters::has_deterministic_seed_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "deterministic_seed" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_deterministic_seed()
{
    if ( is_empty() ) return;
    data()->erase( "deterministic_seed" );
}

void Parameters::set_deterministic_seed( u64 deterministic_seed )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"deterministic_seed\". Object is empty." };
    pre_validate_deterministic_seed( deterministic_seed );
    data()->operator[]( "deterministic_seed" ) = deterministic_seed;
}

void Parameters::pre_validate_deterministic_seed( [[maybe_unused]] u64 deterministic_seed )
{}

// "input_velo_index" property

[[nodiscard]] i32 Parameters::input_velo_index() const
{
    if ( is_empty() ) return default_input_velo_index();
    auto it = data()->find( "input_velo_index" );
    if ( it == data()->end() || it->is_null() ) return default_input_velo_index();
    return it->template get< i32 >();
}

[[nodiscard]] bool Parameters::has_input_velo_index_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "input_velo_index" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_input_velo_index()
{
    if ( is_empty() ) return;
    data()->erase( "input_velo_index" );
}

void Parameters::set_input_velo_index( i32 input_velo_index )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"input_velo_index\". Object is empty." };
    pre_validate_input_velo_index( input_velo_index );
    data()->operator[]( "input_velo_index" ) = input_velo_index;
}

void Parameters::pre_validate_input_velo_index( [[maybe_unused]] i32 input_velo_index )
{
    auto value = input_velo_index;
    if ( value < 1 )
    {
        throw std::runtime_error{ "Validation failed for property 'input_velo_index': Value is not within required range." };
    }
    
}

// "forcing_type" property

[[nodiscard]] ForcingType Parameters::forcing_type() const
{
    if ( is_empty() ) return default_forcing_type();
    auto it = data()->find( "forcing_type" );
    if ( it == data()->end() || it->is_null() ) return default_forcing_type();
    return it->template get< ForcingType >();
}

[[nodiscard]] bool Parameters::has_forcing_type_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "forcing_type" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_forcing_type()
{
    if ( is_empty() ) return;
    data()->erase( "forcing_type" );
}

void Parameters::set_forcing_type( ForcingType forcing_type )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"forcing_type\". Object is empty." };
    pre_validate_forcing_type( forcing_type );
    data()->operator[]( "forcing_type" ) = forcing_type;
}

void Parameters::pre_validate_forcing_type( [[maybe_unused]] ForcingType forcing_type )
{}

// "deterministic_forcing_k_1" property

[[nodiscard]] real Parameters::deterministic_forcing_k_1() const
{
    if ( is_empty() ) return default_deterministic_forcing_k_1();
    auto it = data()->find( "deterministic_forcing_k_1" );
    if ( it == data()->end() || it->is_null() ) return default_deterministic_forcing_k_1();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_deterministic_forcing_k_1_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "deterministic_forcing_k_1" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_deterministic_forcing_k_1()
{
    if ( is_empty() ) return;
    data()->erase( "deterministic_forcing_k_1" );
}

void Parameters::set_deterministic_forcing_k_1( real deterministic_forcing_k_1 )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"deterministic_forcing_k_1\". Object is empty." };
    pre_validate_deterministic_forcing_k_1( deterministic_forcing_k_1 );
    data()->operator[]( "deterministic_forcing_k_1" ) = deterministic_forcing_k_1;
}

void Parameters::pre_validate_deterministic_forcing_k_1( [[maybe_unused]] real deterministic_forcing_k_1 )
{
    auto value = deterministic_forcing_k_1;
    if ( value < 0.0 )
    {
        throw std::runtime_error{ "Validation failed for property 'deterministic_forcing_k_1': Value is not within required range." };
    }
    
}

// "deterministic_forcing_k_2" property

[[nodiscard]] real Parameters::deterministic_forcing_k_2() const
{
    if ( is_empty() ) return default_deterministic_forcing_k_2();
    auto it = data()->find( "deterministic_forcing_k_2" );
    if ( it == data()->end() || it->is_null() ) return default_deterministic_forcing_k_2();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_deterministic_forcing_k_2_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "deterministic_forcing_k_2" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_deterministic_forcing_k_2()
{
    if ( is_empty() ) return;
    data()->erase( "deterministic_forcing_k_2" );
}

void Parameters::set_deterministic_forcing_k_2( real deterministic_forcing_k_2 )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"deterministic_forcing_k_2\". Object is empty." };
    pre_validate_deterministic_forcing_k_2( deterministic_forcing_k_2 );
    data()->operator[]( "deterministic_forcing_k_2" ) = deterministic_forcing_k_2;
}

void Parameters::pre_validate_deterministic_forcing_k_2( [[maybe_unused]] real deterministic_forcing_k_2 )
{
    auto value = deterministic_forcing_k_2;
    if ( value < 0.0 )
    {
        throw std::runtime_error{ "Validation failed for property 'deterministic_forcing_k_2': Value is not within required range." };
    }
    
}

// "stochastic_seed" property

[[nodiscard]] u64 Parameters::stochastic_seed() const
{
    if ( is_empty() ) return default_stochastic_seed();
    auto it = data()->find( "stochastic_seed" );
    if ( it == data()->end() || it->is_null() ) return default_stochastic_seed();
    return it->template get< u64 >();
}

[[nodiscard]] bool Parameters::has_stochastic_seed_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "stochastic_seed" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_stochastic_seed()
{
    if ( is_empty() ) return;
    data()->erase( "stochastic_seed" );
}

void Parameters::set_stochastic_seed( u64 stochastic_seed )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"stochastic_seed\". Object is empty." };
    pre_validate_stochastic_seed( stochastic_seed );
    data()->operator[]( "stochastic_seed" ) = stochastic_seed;
}

void Parameters::pre_validate_stochastic_seed( [[maybe_unused]] u64 stochastic_seed )
{}

// "stats_output_interval" property

[[nodiscard]] i32 Parameters::stats_output_interval() const
{
    if ( is_empty() ) return default_stats_output_interval();
    auto it = data()->find( "stats_output_interval" );
    if ( it == data()->end() || it->is_null() ) return default_stats_output_interval();
    return it->template get< i32 >();
}

[[nodiscard]] bool Parameters::has_stats_output_interval_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "stats_output_interval" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_stats_output_interval()
{
    if ( is_empty() ) return;
    data()->erase( "stats_output_interval" );
}

void Parameters::set_stats_output_interval( i32 stats_output_interval )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"stats_output_interval\". Object is empty." };
    pre_validate_stats_output_interval( stats_output_interval );
    data()->operator[]( "stats_output_interval" ) = stats_output_interval;
}

void Parameters::pre_validate_stats_output_interval( [[maybe_unused]] i32 stats_output_interval )
{
    
}

// "spectrum_output_interval" property

[[nodiscard]] i32 Parameters::spectrum_output_interval() const
{
    if ( is_empty() ) return default_spectrum_output_interval();
    auto it = data()->find( "spectrum_output_interval" );
    if ( it == data()->end() || it->is_null() ) return default_spectrum_output_interval();
    return it->template get< i32 >();
}

[[nodiscard]] bool Parameters::has_spectrum_output_interval_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "spectrum_output_interval" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_spectrum_output_interval()
{
    if ( is_empty() ) return;
    data()->erase( "spectrum_output_interval" );
}

void Parameters::set_spectrum_output_interval( i32 spectrum_output_interval )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"spectrum_output_interval\". Object is empty." };
    pre_validate_spectrum_output_interval( spectrum_output_interval );
    data()->operator[]( "spectrum_output_interval" ) = spectrum_output_interval;
}

void Parameters::pre_validate_spectrum_output_interval( [[maybe_unused]] i32 spectrum_output_interval )
{
    
}

// "is_stats_output_extended" property

[[nodiscard]] bool Parameters::is_stats_output_extended() const
{
    if ( is_empty() ) return default_is_stats_output_extended();
    auto it = data()->find( "is_stats_output_extended" );
    if ( it == data()->end() || it->is_null() ) return default_is_stats_output_extended();
    return it->template get< bool >();
}

[[nodiscard]] bool Parameters::has_is_stats_output_extended_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "is_stats_output_extended" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_is_stats_output_extended()
{
    if ( is_empty() ) return;
    data()->erase( "is_stats_output_extended" );
}

void Parameters::set_is_stats_output_extended( bool is_stats_output_extended )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"is_stats_output_extended\". Object is empty." };
    pre_validate_is_stats_output_extended( is_stats_output_extended );
    data()->operator[]( "is_stats_output_extended" ) = is_stats_output_extended;
}

void Parameters::pre_validate_is_stats_output_extended( [[maybe_unused]] bool is_stats_output_extended )
{}

// "rho_part" property

[[nodiscard]] real Parameters::rho_part() const
{
    if ( is_empty() ) return default_rho_part();
    auto it = data()->find( "rho_part" );
    if ( it == data()->end() || it->is_null() ) return default_rho_part();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_rho_part_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "rho_part" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_rho_part()
{
    if ( is_empty() ) return;
    data()->erase( "rho_part" );
}

void Parameters::set_rho_part( real rho_part )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"rho_part\". Object is empty." };
    pre_validate_rho_part( rho_part );
    data()->operator[]( "rho_part" ) = rho_part;
}

void Parameters::pre_validate_rho_part( [[maybe_unused]] real rho_part )
{
    auto value = rho_part;
    if ( value < 0.0 )
    {
        throw std::runtime_error{ "Validation failed for property 'rho_part': Value is not within required range." };
    }
    
}

// "rho_fluid" property

[[nodiscard]] real Parameters::rho_fluid() const
{
    if ( is_empty() ) return default_rho_fluid();
    auto it = data()->find( "rho_fluid" );
    if ( it == data()->end() || it->is_null() ) return default_rho_fluid();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_rho_fluid_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "rho_fluid" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_rho_fluid()
{
    if ( is_empty() ) return;
    data()->erase( "rho_fluid" );
}

void Parameters::set_rho_fluid( real rho_fluid )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"rho_fluid\". Object is empty." };
    pre_validate_rho_fluid( rho_fluid );
    data()->operator[]( "rho_fluid" ) = rho_fluid;
}

void Parameters::pre_validate_rho_fluid( [[maybe_unused]] real rho_fluid )
{
    auto value = rho_fluid;
    if ( value < 0.0 )
    {
        throw std::runtime_error{ "Validation failed for property 'rho_fluid': Value is not within required range." };
    }
    
}

// "eta_k_init" property

[[nodiscard]] real Parameters::eta_k_init() const
{
    if ( is_empty() ) return default_eta_k_init();
    auto it = data()->find( "eta_k_init" );
    if ( it == data()->end() || it->is_null() ) return default_eta_k_init();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_eta_k_init_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "eta_k_init" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_eta_k_init()
{
    if ( is_empty() ) return;
    data()->erase( "eta_k_init" );
}

void Parameters::set_eta_k_init( real eta_k_init )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"eta_k_init\". Object is empty." };
    pre_validate_eta_k_init( eta_k_init );
    data()->operator[]( "eta_k_init" ) = eta_k_init;
}

void Parameters::pre_validate_eta_k_init( [[maybe_unused]] real eta_k_init )
{
    auto value = eta_k_init;
    if ( value < 0.0 )
    {
        throw std::runtime_error{ "Validation failed for property 'eta_k_init': Value is not within required range." };
    }
    
}

// "tau_k_init" property

[[nodiscard]] real Parameters::tau_k_init() const
{
    if ( is_empty() ) return default_tau_k_init();
    auto it = data()->find( "tau_k_init" );
    if ( it == data()->end() || it->is_null() ) return default_tau_k_init();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_tau_k_init_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "tau_k_init" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_tau_k_init()
{
    if ( is_empty() ) return;
    data()->erase( "tau_k_init" );
}

void Parameters::set_tau_k_init( real tau_k_init )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"tau_k_init\". Object is empty." };
    pre_validate_tau_k_init( tau_k_init );
    data()->operator[]( "tau_k_init" ) = tau_k_init;
}

void Parameters::pre_validate_tau_k_init( [[maybe_unused]] real tau_k_init )
{
    auto value = tau_k_init;
    if ( value < 0.0 )
    {
        throw std::runtime_error{ "Validation failed for property 'tau_k_init': Value is not within required range." };
    }
    
}

// "shell_thickness" property

[[nodiscard]] real Parameters::shell_thickness() const
{
    if ( is_empty() ) return default_shell_thickness();
    auto it = data()->find( "shell_thickness" );
    if ( it == data()->end() || it->is_null() ) return default_shell_thickness();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_shell_thickness_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "shell_thickness" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_shell_thickness()
{
    if ( is_empty() ) return;
    data()->erase( "shell_thickness" );
}

void Parameters::set_shell_thickness( real shell_thickness )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"shell_thickness\". Object is empty." };
    pre_validate_shell_thickness( shell_thickness );
    data()->operator[]( "shell_thickness" ) = shell_thickness;
}

void Parameters::pre_validate_shell_thickness( [[maybe_unused]] real shell_thickness )
{
    auto value = shell_thickness;
    if ( value < 0.0 )
    {
        throw std::runtime_error{ "Validation failed for property 'shell_thickness': Value is not within required range." };
    }
    
}

// "epsilon_env" property

[[nodiscard]] real Parameters::epsilon_env() const
{
    if ( is_empty() ) return default_epsilon_env();
    auto it = data()->find( "epsilon_env" );
    if ( it == data()->end() || it->is_null() ) return default_epsilon_env();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_epsilon_env_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "epsilon_env" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_epsilon_env()
{
    if ( is_empty() ) return;
    data()->erase( "epsilon_env" );
}

void Parameters::set_epsilon_env( real epsilon_env )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"epsilon_env\". Object is empty." };
    pre_validate_epsilon_env( epsilon_env );
    data()->operator[]( "epsilon_env" ) = epsilon_env;
}

void Parameters::pre_validate_epsilon_env( [[maybe_unused]] real epsilon_env )
{
    auto value = epsilon_env;
    if ( value < 0.0 )
    {
        throw std::runtime_error{ "Validation failed for property 'epsilon_env': Value is not within required range." };
    }
    
}

// "nu_fluid" property

[[nodiscard]] real Parameters::nu_fluid() const
{
    if ( is_empty() ) return default_nu_fluid();
    auto it = data()->find( "nu_fluid" );
    if ( it == data()->end() || it->is_null() ) return default_nu_fluid();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_nu_fluid_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "nu_fluid" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_nu_fluid()
{
    if ( is_empty() ) return;
    data()->erase( "nu_fluid" );
}

void Parameters::set_nu_fluid( real nu_fluid )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"nu_fluid\". Object is empty." };
    pre_validate_nu_fluid( nu_fluid );
    data()->operator[]( "nu_fluid" ) = nu_fluid;
}

void Parameters::pre_validate_nu_fluid( [[maybe_unused]] real nu_fluid )
{
    auto value = nu_fluid;
    if ( value < 0.0 )
    {
        throw std::runtime_error{ "Validation failed for property 'nu_fluid': Value is not within required range." };
    }
    
}

// "gravity" property

[[nodiscard]] real Parameters::gravity() const
{
    if ( is_empty() ) return default_gravity();
    auto it = data()->find( "gravity" );
    if ( it == data()->end() || it->is_null() ) return default_gravity();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_gravity_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "gravity" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_gravity()
{
    if ( is_empty() ) return;
    data()->erase( "gravity" );
}

void Parameters::set_gravity( real gravity )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"gravity\". Object is empty." };
    pre_validate_gravity( gravity );
    data()->operator[]( "gravity" ) = gravity;
}

void Parameters::pre_validate_gravity( [[maybe_unused]] real gravity )
{}

// "is_part_generated" property

[[nodiscard]] bool Parameters::is_part_generated() const
{
    if ( is_empty() ) return default_is_part_generated();
    auto it = data()->find( "is_part_generated" );
    if ( it == data()->end() || it->is_null() ) return default_is_part_generated();
    return it->template get< bool >();
}

[[nodiscard]] bool Parameters::has_is_part_generated_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "is_part_generated" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_is_part_generated()
{
    if ( is_empty() ) return;
    data()->erase( "is_part_generated" );
}

void Parameters::set_is_part_generated( bool is_part_generated )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"is_part_generated\". Object is empty." };
    pre_validate_is_part_generated( is_part_generated );
    data()->operator[]( "is_part_generated" ) = is_part_generated;
}

void Parameters::pre_validate_is_part_generated( [[maybe_unused]] bool is_part_generated )
{}

// "is_part_overlapping" property

[[nodiscard]] bool Parameters::is_part_overlapping() const
{
    if ( is_empty() ) return default_is_part_overlapping();
    auto it = data()->find( "is_part_overlapping" );
    if ( it == data()->end() || it->is_null() ) return default_is_part_overlapping();
    return it->template get< bool >();
}

[[nodiscard]] bool Parameters::has_is_part_overlapping_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "is_part_overlapping" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_is_part_overlapping()
{
    if ( is_empty() ) return;
    data()->erase( "is_part_overlapping" );
}

void Parameters::set_is_part_overlapping( bool is_part_overlapping )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"is_part_overlapping\". Object is empty." };
    pre_validate_is_part_overlapping( is_part_overlapping );
    data()->operator[]( "is_part_overlapping" ) = is_part_overlapping;
}

void Parameters::pre_validate_is_part_overlapping( [[maybe_unused]] bool is_part_overlapping )
{}

// "is_part_hdi_enabled" property

[[nodiscard]] bool Parameters::is_part_hdi_enabled() const
{
    if ( is_empty() ) return default_is_part_hdi_enabled();
    auto it = data()->find( "is_part_hdi_enabled" );
    if ( it == data()->end() || it->is_null() ) return default_is_part_hdi_enabled();
    return it->template get< bool >();
}

[[nodiscard]] bool Parameters::has_is_part_hdi_enabled_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "is_part_hdi_enabled" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_is_part_hdi_enabled()
{
    if ( is_empty() ) return;
    data()->erase( "is_part_hdi_enabled" );
}

void Parameters::set_is_part_hdi_enabled( bool is_part_hdi_enabled )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"is_part_hdi_enabled\". Object is empty." };
    pre_validate_is_part_hdi_enabled( is_part_hdi_enabled );
    data()->operator[]( "is_part_hdi_enabled" ) = is_part_hdi_enabled;
}

void Parameters::pre_validate_is_part_hdi_enabled( [[maybe_unused]] bool is_part_hdi_enabled )
{}

// "part_hdi_trunc_enabled" property

[[nodiscard]] real Parameters::part_hdi_trunc_enabled() const
{
    if ( is_empty() ) return default_part_hdi_trunc_enabled();
    auto it = data()->find( "part_hdi_trunc_enabled" );
    if ( it == data()->end() || it->is_null() ) return default_part_hdi_trunc_enabled();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_part_hdi_trunc_enabled_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "part_hdi_trunc_enabled" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_part_hdi_trunc_enabled()
{
    if ( is_empty() ) return;
    data()->erase( "part_hdi_trunc_enabled" );
}

void Parameters::set_part_hdi_trunc_enabled( real part_hdi_trunc_enabled )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"part_hdi_trunc_enabled\". Object is empty." };
    pre_validate_part_hdi_trunc_enabled( part_hdi_trunc_enabled );
    data()->operator[]( "part_hdi_trunc_enabled" ) = part_hdi_trunc_enabled;
}

void Parameters::pre_validate_part_hdi_trunc_enabled( [[maybe_unused]] real part_hdi_trunc_enabled )
{
    auto value = part_hdi_trunc_enabled;
    if ( value < 0.0 )
    {
        throw std::runtime_error{ "Validation failed for property 'part_hdi_trunc_enabled': Value is not within required range." };
    }
    
}

// "N_part" property

[[nodiscard]] i32 Parameters::N_part() const
{
    if ( is_empty() ) return default_N_part();
    auto it = data()->find( "N_part" );
    if ( it == data()->end() || it->is_null() ) return default_N_part();
    return it->template get< i32 >();
}

[[nodiscard]] bool Parameters::has_N_part_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "N_part" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_N_part()
{
    if ( is_empty() ) return;
    data()->erase( "N_part" );
}

void Parameters::set_N_part( i32 N_part )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"N_part\". Object is empty." };
    pre_validate_N_part( N_part );
    data()->operator[]( "N_part" ) = N_part;
}

void Parameters::pre_validate_N_part( [[maybe_unused]] i32 N_part )
{
    
}

// "drag_type" property

[[nodiscard]] DragType Parameters::drag_type() const
{
    if ( is_empty() ) return default_drag_type();
    auto it = data()->find( "drag_type" );
    if ( it == data()->end() || it->is_null() ) return default_drag_type();
    return it->template get< DragType >();
}

[[nodiscard]] bool Parameters::has_drag_type_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "drag_type" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_drag_type()
{
    if ( is_empty() ) return;
    data()->erase( "drag_type" );
}

void Parameters::set_drag_type( DragType drag_type )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"drag_type\". Object is empty." };
    pre_validate_drag_type( drag_type );
    data()->operator[]( "drag_type" ) = drag_type;
}

void Parameters::pre_validate_drag_type( [[maybe_unused]] DragType drag_type )
{}

// "a" property

[[nodiscard]] real Parameters::a() const
{
    if ( is_empty() ) return default_a();
    auto it = data()->find( "a" );
    if ( it == data()->end() || it->is_null() ) return default_a();
    return it->template get< real >();
}

[[nodiscard]] bool Parameters::has_a_set() const noexcept
{
    if ( is_empty() ) return false;
    auto it = data()->find( "a" );
    return it != data()->end() && !it->is_null();
}

void Parameters::reset_a()
{
    if ( is_empty() ) return;
    data()->erase( "a" );
}

void Parameters::set_a( real a )
{
    if ( is_empty() ) throw std::runtime_error{ "Cannot set value for property \"a\". Object is empty." };
    pre_validate_a( a );
    data()->operator[]( "a" ) = a;
}

void Parameters::pre_validate_a( [[maybe_unused]] real a )
{
    auto value = a;
    if ( value < 0.0 )
    {
        throw std::runtime_error{ "Validation failed for property 'a': Value is not within required range." };
    }
    
}


} // end of namespace vortex::turb::legacy::settings
