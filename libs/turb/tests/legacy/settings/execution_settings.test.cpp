// 
// Unit test source file auto-generated by VORTEX SETTINGS WIZARD
// 
// TODO: Just testing
// 

#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_floating_point.hpp>
#include <nlohmann/json.hpp>

#include "turb/legacy/settings/execution_settings.hpp"

TEST_CASE( "ExecutionSettings - basic test", "[settings]" )
{
    nlohmann::json obj = nlohmann::json::object();
    auto s = vortex::turb::legacy::settings::ExecutionSettings{ &obj };

    REQUIRE( !s.is_empty() );

    auto data_p = s.data();
    auto anys = s.as_any();

    REQUIRE( !anys.is_empty() );

    auto ss = vortex::turb::legacy::settings::ExecutionSettings{ anys };

    REQUIRE( !ss.is_empty() );
    REQUIRE( data_p != nullptr );
    REQUIRE( obj == *data_p );
    REQUIRE( *anys.data() == *data_p );
    REQUIRE( *ss.data() == *data_p );
}

TEST_CASE( "ExecutionSettings - basic empty test", "[settings]" )
{
    auto s = vortex::turb::legacy::settings::ExecutionSettings{};

    REQUIRE( s.is_empty() );

    auto anys = s.as_any();

    REQUIRE( anys.is_empty() );

    auto ss = vortex::turb::legacy::settings::ExecutionSettings{ anys };

    REQUIRE( ss.is_empty() );
    REQUIRE( s.data() == nullptr );
    REQUIRE( anys.data() == nullptr );
    REQUIRE( ss.data() == nullptr );
}

TEST_CASE( "ExecutionSettings - conversion to string", "[settings][.][!mayfail]" )
{
    // TODO - add conversion to string tests for generated setting classes
    REQUIRE( false );
}

TEST_CASE( "ExecutionSettings - conversion to string - display all", "[settings][.][!mayfail]" )
{
    // TODO - add conversion to string tests for generated setting classes
    REQUIRE( false );
}

TEST_CASE( "ExecutionSettings - conversion to string - extra indent size", "[settings][.][!mayfail]" )
{
    // TODO - add conversion to string tests for generated setting classes
    REQUIRE( false );
}

TEST_CASE( "ExecutionSettings - conversion to string - extra indent level", "[settings][.][!mayfail]" )
{
    // TODO - add conversion to string tests for generated setting classes
    REQUIRE( false );
}

TEST_CASE( "ExecutionSettings - conversion to string for empty", "[settings][.][!mayfail]" )
{
    // TODO - add conversion to string tests for generated setting classes
    REQUIRE( false );
}

TEST_CASE( "ExecutionSettings - merge", "[settings][.][!mayfail]" )
{
    // TODO - add merge tests for generated setting classes
    REQUIRE( false );
}

TEST_CASE( "ExecutionSettings - merge with removal", "[settings][.][!mayfail]" )
{
    // TODO - add merge tests for generated setting classes
    REQUIRE( false );
}

TEST_CASE( "ExecutionSettings - merge with empties", "[settings][.][!mayfail]" )
{
    // TODO - add merge tests for generated setting classes
    REQUIRE( false );
}

TEST_CASE( "ExecutionSettings - equality and inequality operators", "[settings][.][!mayfail]" )
{
    // TODO - add merge tests for generated setting classes
    REQUIRE( false );
}

// "job_name" property

TEST_CASE( "ExecutionSettings - property: \"job_name\" - getter, default, has_set", "[settings]" )
{
    nlohmann::json obj = { { "job_name", "stest" } };
    auto s = vortex::turb::legacy::settings::ExecutionSettings{ &obj };
    auto s_null = vortex::turb::legacy::settings::ExecutionSettings{};

    auto value = s.job_name();
    auto default_value = s_null.job_name();

    REQUIRE( value == "stest" );
    REQUIRE( default_value == std::string_view{} );

    REQUIRE( s.has_job_name_set() );
    REQUIRE( !s_null.has_job_name_set() );
}

TEST_CASE( "ExecutionSettings - property: \"job_name\" - setter, reset", "[settings]" )
{
    nlohmann::json obj = nlohmann::json::object();
    auto s = vortex::turb::legacy::settings::ExecutionSettings{ &obj };
    auto s_null = vortex::turb::legacy::settings::ExecutionSettings{};

    const auto sv = std::string_view{ "sv" };
    const auto str = std::string{ "str" };
    const auto cstr = "cstr";

    REQUIRE( !s.has_job_name_set() );
    REQUIRE( !s_null.has_job_name_set() );

    REQUIRE_NOTHROW( s.reset_job_name() );
    REQUIRE_NOTHROW( s_null.reset_job_name() );

    REQUIRE_THROWS_AS( s_null.set_job_name( sv ), std::runtime_error );
    REQUIRE_THROWS_AS( s_null.set_job_name( str ), std::runtime_error );
    REQUIRE_THROWS_AS( s_null.set_job_name( cstr ), std::runtime_error );
    REQUIRE_THROWS_AS( s_null.set_job_name( std::string{ "mvstr" } ), std::runtime_error );

    s.set_job_name( sv );
    REQUIRE( s.has_job_name_set() );
    REQUIRE( s.job_name() == "sv" );

    s.set_job_name( str );
    REQUIRE( s.has_job_name_set() );
    REQUIRE( s.job_name() == "str" );

    s.set_job_name( cstr );
    REQUIRE( s.has_job_name_set() );
    REQUIRE( s.job_name() == "cstr" );

    s.set_job_name( std::string{ "mvstr" } );
    REQUIRE( s.has_job_name_set() );
    REQUIRE( s.job_name() == "mvstr" );

    s.reset_job_name();
    REQUIRE( !s.has_job_name_set() );

}

// "grant_no" property

TEST_CASE( "ExecutionSettings - property: \"grant_no\" - getter, default, has_set", "[settings]" )
{
    nlohmann::json obj = { { "grant_no", "stest" } };
    auto s = vortex::turb::legacy::settings::ExecutionSettings{ &obj };
    auto s_null = vortex::turb::legacy::settings::ExecutionSettings{};

    auto value = s.grant_no();
    auto default_value = s_null.grant_no();

    REQUIRE( value == "stest" );
    REQUIRE( default_value == std::string_view{} );

    REQUIRE( s.has_grant_no_set() );
    REQUIRE( !s_null.has_grant_no_set() );
}

TEST_CASE( "ExecutionSettings - property: \"grant_no\" - setter, reset", "[settings]" )
{
    nlohmann::json obj = nlohmann::json::object();
    auto s = vortex::turb::legacy::settings::ExecutionSettings{ &obj };
    auto s_null = vortex::turb::legacy::settings::ExecutionSettings{};

    const auto sv = std::string_view{ "sv" };
    const auto str = std::string{ "str" };
    const auto cstr = "cstr";

    REQUIRE( !s.has_grant_no_set() );
    REQUIRE( !s_null.has_grant_no_set() );

    REQUIRE_NOTHROW( s.reset_grant_no() );
    REQUIRE_NOTHROW( s_null.reset_grant_no() );

    REQUIRE_THROWS_AS( s_null.set_grant_no( sv ), std::runtime_error );
    REQUIRE_THROWS_AS( s_null.set_grant_no( str ), std::runtime_error );
    REQUIRE_THROWS_AS( s_null.set_grant_no( cstr ), std::runtime_error );
    REQUIRE_THROWS_AS( s_null.set_grant_no( std::string{ "mvstr" } ), std::runtime_error );

    s.set_grant_no( sv );
    REQUIRE( s.has_grant_no_set() );
    REQUIRE( s.grant_no() == "sv" );

    s.set_grant_no( str );
    REQUIRE( s.has_grant_no_set() );
    REQUIRE( s.grant_no() == "str" );

    s.set_grant_no( cstr );
    REQUIRE( s.has_grant_no_set() );
    REQUIRE( s.grant_no() == "cstr" );

    s.set_grant_no( std::string{ "mvstr" } );
    REQUIRE( s.has_grant_no_set() );
    REQUIRE( s.grant_no() == "mvstr" );

    s.reset_grant_no();
    REQUIRE( !s.has_grant_no_set() );

}

// "cpu_node_count" property

TEST_CASE( "ExecutionSettings - property: \"cpu_node_count\" - getter, default, has_set", "[settings]" )
{
    nlohmann::json obj = { { "cpu_node_count", -2l } };
    auto s = vortex::turb::legacy::settings::ExecutionSettings{ &obj };
    auto s_null = vortex::turb::legacy::settings::ExecutionSettings{};

    auto value = s.cpu_node_count();
    auto default_value = s_null.cpu_node_count();

    REQUIRE( static_cast< vortex::i32 >( value ) == -2l );
    REQUIRE( static_cast< vortex::i32 >( default_value ) == 1 );

    REQUIRE( s.has_cpu_node_count_set() );
    REQUIRE( !s_null.has_cpu_node_count_set() );
}

TEST_CASE( "ExecutionSettings - property: \"cpu_node_count\" - setter, reset", "[settings]" )
{
    nlohmann::json obj = nlohmann::json::object();
    auto s = vortex::turb::legacy::settings::ExecutionSettings{ &obj };
    auto s_null = vortex::turb::legacy::settings::ExecutionSettings{};

    const auto value = -2l;

    REQUIRE( !s.has_cpu_node_count_set() );
    REQUIRE( !s_null.has_cpu_node_count_set() );

    REQUIRE_NOTHROW( s.reset_cpu_node_count() );
    REQUIRE_NOTHROW( s_null.reset_cpu_node_count() );

    REQUIRE_THROWS_AS( s_null.set_cpu_node_count( value ), std::runtime_error );

    s.set_cpu_node_count( value );
    REQUIRE( s.has_cpu_node_count_set() );
    REQUIRE( s.cpu_node_count() == value );

    s.reset_cpu_node_count();
    REQUIRE( !s.has_cpu_node_count_set() );

}

// "wct_limit" property

TEST_CASE( "ExecutionSettings - property: \"wct_limit\" - getter, default, has_set", "[settings]" )
{
    nlohmann::json obj = { { "wct_limit", 0.2 } };
    auto s = vortex::turb::legacy::settings::ExecutionSettings{ &obj };
    auto s_null = vortex::turb::legacy::settings::ExecutionSettings{};

    auto value = s.wct_limit();
    auto default_value = s_null.wct_limit();

    REQUIRE_THAT( static_cast< vortex::f64 >( value ), Catch::Matchers::WithinAbs( 0.2, 1e-05 ) );
    REQUIRE_THAT( static_cast< vortex::f64 >( default_value ), Catch::Matchers::WithinAbs( 60.0, 1e-05 ) );

    REQUIRE( s.has_wct_limit_set() );
    REQUIRE( !s_null.has_wct_limit_set() );
}

TEST_CASE( "ExecutionSettings - property: \"wct_limit\" - setter, reset", "[settings]" )
{
    nlohmann::json obj = nlohmann::json::object();
    auto s = vortex::turb::legacy::settings::ExecutionSettings{ &obj };
    auto s_null = vortex::turb::legacy::settings::ExecutionSettings{};

    const auto value = 0.2;

    REQUIRE( !s.has_wct_limit_set() );
    REQUIRE( !s_null.has_wct_limit_set() );

    REQUIRE_NOTHROW( s.reset_wct_limit() );
    REQUIRE_NOTHROW( s_null.reset_wct_limit() );

    REQUIRE_THROWS_AS( s_null.set_wct_limit( value ), std::runtime_error );

    s.set_wct_limit( value );
    REQUIRE( s.has_wct_limit_set() );
    REQUIRE_THAT( s.wct_limit(), Catch::Matchers::WithinAbs( value, 1e-05 ) );

    s.reset_wct_limit();
    REQUIRE( !s.has_wct_limit_set() );

}

// "process_count" property

TEST_CASE( "ExecutionSettings - property: \"process_count\" - getter, default, has_set", "[settings]" )
{
    nlohmann::json obj = { { "process_count", -2l } };
    auto s = vortex::turb::legacy::settings::ExecutionSettings{ &obj };
    auto s_null = vortex::turb::legacy::settings::ExecutionSettings{};

    auto value = s.process_count();
    auto default_value = s_null.process_count();

    REQUIRE( static_cast< vortex::i32 >( value ) == -2l );
    REQUIRE( static_cast< vortex::i32 >( default_value ) == 1 );

    REQUIRE( s.has_process_count_set() );
    REQUIRE( !s_null.has_process_count_set() );
}

TEST_CASE( "ExecutionSettings - property: \"process_count\" - setter, reset", "[settings]" )
{
    nlohmann::json obj = nlohmann::json::object();
    auto s = vortex::turb::legacy::settings::ExecutionSettings{ &obj };
    auto s_null = vortex::turb::legacy::settings::ExecutionSettings{};

    const auto value = -2l;

    REQUIRE( !s.has_process_count_set() );
    REQUIRE( !s_null.has_process_count_set() );

    REQUIRE_NOTHROW( s.reset_process_count() );
    REQUIRE_NOTHROW( s_null.reset_process_count() );

    REQUIRE_THROWS_AS( s_null.set_process_count( value ), std::runtime_error );

    s.set_process_count( value );
    REQUIRE( s.has_process_count_set() );
    REQUIRE( s.process_count() == value );

    s.reset_process_count();
    REQUIRE( !s.has_process_count_set() );

}

// "is_node_overcommit_enabled" property

TEST_CASE( "ExecutionSettings - property: \"is_node_overcommit_enabled\" - getter, default, has_set", "[settings]" )
{
    nlohmann::json obj = { { "is_node_overcommit_enabled", true } };
    auto s = vortex::turb::legacy::settings::ExecutionSettings{ &obj };
    auto s_null = vortex::turb::legacy::settings::ExecutionSettings{};

    auto value = s.is_node_overcommit_enabled();
    auto default_value = s_null.is_node_overcommit_enabled();

    REQUIRE( value == true );
    REQUIRE( default_value == bool{} );

    REQUIRE( s.has_is_node_overcommit_enabled_set() );
    REQUIRE( !s_null.has_is_node_overcommit_enabled_set() );
}

TEST_CASE( "ExecutionSettings - property: \"is_node_overcommit_enabled\" - setter, reset", "[settings]" )
{
    nlohmann::json obj = nlohmann::json::object();
    auto s = vortex::turb::legacy::settings::ExecutionSettings{ &obj };
    auto s_null = vortex::turb::legacy::settings::ExecutionSettings{};

    const auto value = true;

    REQUIRE( !s.has_is_node_overcommit_enabled_set() );
    REQUIRE( !s_null.has_is_node_overcommit_enabled_set() );

    REQUIRE_NOTHROW( s.reset_is_node_overcommit_enabled() );
    REQUIRE_NOTHROW( s_null.reset_is_node_overcommit_enabled() );

    REQUIRE_THROWS_AS( s_null.set_is_node_overcommit_enabled( value ), std::runtime_error );

    s.set_is_node_overcommit_enabled( value );
    REQUIRE( s.has_is_node_overcommit_enabled_set() );
    REQUIRE( s.is_node_overcommit_enabled() == value );

    s.reset_is_node_overcommit_enabled();
    REQUIRE( !s.has_is_node_overcommit_enabled_set() );

}


